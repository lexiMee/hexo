<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,AudioTrack," />





  <link rel="alternate" href="/atom.xml" title="Thinking" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">
<meta property="og:type" content="article">
<meta property="og:title" content="audiotrack的write流程">
<meta property="og:url" content="http://thinks.me/2016/03/18/audiotrack_write/index.html">
<meta property="og:site_name" content="Thinking">
<meta property="og:description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">
<meta property="og:updated_time" content="2016-03-20T03:16:05.855Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="audiotrack的write流程">
<meta name="twitter:description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> audiotrack的write流程 | Thinking </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1a17ff812788f97b5ec90bee6eba907f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Thinking</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                audiotrack的write流程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T14:23:24+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android开发/" itemprop="url" rel="index">
                    <span itemprop="name">android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/18/audiotrack_write/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/18/audiotrack_write/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="简述">简述</h2><p>到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。</p>
<p>读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：</p>
<blockquote>
<p>生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据。它们是在两个独立的线程里面的。</p>
</blockquote>
<p>所以可能会出现三种情况的数据填写：</p>
<ol>
<li>生产者极快。生产者数据写完了，等待消费者消费到minbuffersize，然后唤醒生产者继续填充，在消费者进行下次消费之前已经填充完，又进入等待。看起来好像是有序的填充，等待，消费，唤醒，填充，等待，消费，唤醒的线性逻辑</li>
<li>生产和消费速度相当。生产者数据写完了，等待消费者消费到minbuffersize，然后唤醒生产者继续填充，生产者的生产速度极慢，每次填充都正好满足消费者的。这边看起来就是异步的了，一边一直在填充、一边一直在消费，基本上没有唤醒情况</li>
<li>生产速度远远小于消费速度。生产者的数据写入太慢，消费者消费过快，这个时候就会出现underrun了，这个时候消费者会给生产者一定的机会，如果还是没能够给到数据，则就将其赶出判断的行列。</li>
</ol>
<a id="more"></a>
<h2 id="正文">正文</h2><h3 id="生产者部分">生产者部分</h3><p>从java开始看，我们平常调用的不指定是否阻塞，默认就是阻塞的。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(@NonNull <span class="keyword">short</span>[] audioData, <span class="keyword">int</span> offsetInShorts, <span class="keyword">int</span> sizeInShorts)</span> </span>{
    <span class="keyword">return</span> write(audioData, offsetInShorts, sizeInShorts, WRITE_BLOCKING);
}
<span class="comment">// 这边有个需要注意的是，传入的数据所存放的buffer是类型的，比如byte的话，则format不可以为float类型</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(@NonNull byte[] audioData, <span class="keyword">int</span> offsetInBytes, <span class="keyword">int</span> sizeInBytes,
        @WriteMode <span class="keyword">int</span> writeMode)</span> </span>{
    <span class="comment">// 必须已经经过初始化了，并且对format有限制，因为传入的数组是一个byte类型</span>
    <span class="keyword">if</span> (mState == STATE_UNINITIALIZED || mAudioFormat == AudioFormat.ENCODING_PCM_FLOAT) {
        <span class="keyword">return</span> ERROR_INVALID_OPERATION;
    }
    <span class="comment">// writeMode只有两种情况，一种是blocking，另外一种是non blocking</span>
    <span class="keyword">if</span> ((writeMode != WRITE_BLOCKING) &amp;&amp; (writeMode != WRITE_NON_BLOCKING)) {
        <span class="keyword">return</span> ERROR_BAD_VALUE;
    }

    <span class="keyword">if</span> ( (audioData == null) || (offsetInBytes &lt; <span class="number">0</span> ) || (sizeInBytes &lt; <span class="number">0</span>)
            || (offsetInBytes + sizeInBytes &lt; <span class="number">0</span>)    <span class="comment">// detect integer overflow</span>
            || (offsetInBytes + sizeInBytes &gt; audioData.length)) {
        <span class="keyword">return</span> ERROR_BAD_VALUE;
    }

    <span class="keyword">int</span> ret = native_write_byte(audioData, offsetInBytes, sizeInBytes, mAudioFormat,
            writeMode == WRITE_BLOCKING);

    <span class="keyword">if</span> ((mDataLoadMode == MODE_STATIC)
            &amp;&amp; (mState == STATE_NO_STATIC_DATA)
            &amp;&amp; (ret &gt; <span class="number">0</span>)) {
        <span class="comment">// benign race with respect to other APIs that read mState</span>
        mState = STATE_INITIALIZED;
    }

    <span class="keyword">return</span> ret;
}
</code></pre><p>上面函数做了下常规检查，然后就调用native的函数进行执行写的操作了。</p>
<p>看下函数实现<code>native_write_byte</code></p>
<pre><code><span class="function"><span class="keyword">static</span> jint <span class="title">android_media_AudioTrack_write_native_bytes</span><span class="params">(JNIEnv *env,  jobject thiz,
        jbyteArray javaBytes, jint byteOffset, jint sizeInBytes,
        jint javaAudioFormat, jboolean isWriteBlocking)</span> </span>{

    sp&lt;AudioTrack&gt; lpTrack = getAudioTrack(env, thiz);
    <span class="keyword">if</span> (lpTrack == <span class="literal">NULL</span>) {
        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,
                <span class="string">"Unable to retrieve AudioTrack pointer for write()"</span>);
        <span class="keyword">return</span> (jint)AUDIO_JAVA_INVALID_OPERATION;
    }

    <span class="function">ScopedBytesRO <span class="title">bytes</span><span class="params">(env, javaBytes)</span></span>;
    <span class="keyword">if</span> (bytes.get() == <span class="literal">NULL</span>) {
        <span class="keyword">return</span> (jint)AUDIO_JAVA_BAD_VALUE;
    }
    <span class="comment">// 调用writeToTrack执行写的操作</span>
    jint written = writeToTrack(lpTrack, javaAudioFormat, bytes.get(), byteOffset,
            sizeInBytes, isWriteBlocking == JNI_TRUE <span class="comment">/* blocking */</span>);

    <span class="keyword">return</span> written;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">static</span> jint <span class="title">writeToTrack</span><span class="params">(<span class="keyword">const</span> sp&lt;AudioTrack&gt;&amp; track, jint audioFormat, <span class="keyword">const</span> T *data,
                         jint offsetInSamples, jint sizeInSamples, <span class="keyword">bool</span> blocking)</span> </span>{
    <span class="comment">// give the data to the native AudioTrack object (the data starts at the offset)</span>
    <span class="keyword">ssize_t</span> written = <span class="number">0</span>;
    <span class="comment">// regular write() or copy the data to the AudioTrack's shared memory?</span>
    <span class="keyword">size_t</span> sizeInBytes = <span class="function">sizeInSamples * <span class="title">sizeof</span><span class="params">(T)</span></span>;
    <span class="comment">// 如果非share memory的话，直接调用audiotrack的write函数</span>
    <span class="keyword">if</span> (track-&gt;sharedBuffer() == <span class="number">0</span>) {
        written = track-&gt;write(data + offsetInSamples, sizeInBytes, blocking);
        <span class="comment">// for compatibility with earlier behavior of write(), return 0 in this case</span>
        <span class="keyword">if</span> (written == (<span class="keyword">ssize_t</span>) WOULD_BLOCK) {
            written = <span class="number">0</span>;
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 写到share memory，检查下容量</span>
        <span class="comment">// writing to shared memory, check for capacity</span>
        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)sizeInBytes &gt; track-&gt;sharedBuffer()-&gt;size()) {
            sizeInBytes = track-&gt;sharedBuffer()-&gt;size();
        }
        <span class="comment">// 直接进行拷贝</span>
        <span class="built_in">memcpy</span>(track-&gt;sharedBuffer()-&gt;pointer(), data + offsetInSamples, sizeInBytes);
        written = sizeInBytes;
    }
    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) {
        <span class="keyword">return</span> written / <span class="keyword">sizeof</span>(T);
    }
    <span class="comment">// for compatibility, error codes pass through unchanged</span>
    <span class="keyword">return</span> written;
}
</code></pre><p>上面的函数只是简单进行write的操作，我们现在进入主体函数。</p>
<pre><code><span class="keyword">ssize_t</span> AudioTrack::write(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> userSize, <span class="keyword">bool</span> blocking)
{
    <span class="comment">// 该write函数要求mTransfer必须为TRANSFER_SYNC并且不是timetrack</span>
    <span class="keyword">if</span> (mTransfer != TRANSFER_SYNC || mIsTimed) {
        <span class="keyword">return</span> INVALID_OPERATION;
    }
    <span class="comment">// 判断下flag中是否带有direct flag，如果是flag，则去掉CBLK_UNDERRUN、CBLK_LOOP_CYCLE</span>
    <span class="comment">// CBLK_LOOP_FINAL、CBLK_BUFFER_END</span>
    <span class="keyword">if</span> (isDirect()) {
        <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;
        <span class="keyword">int32_t</span> flags = android_atomic_and(
                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),
                            &amp;mCblk-&gt;mFlags);
        <span class="comment">// 如果此时flag还含有CBLK_INVALID flag</span>
        <span class="keyword">if</span> (flags &amp; CBLK_INVALID) {
            <span class="keyword">return</span> DEAD_OBJECT;
        }
    }

    <span class="keyword">if</span> (<span class="keyword">ssize_t</span>(userSize) &lt; <span class="number">0</span> || (buffer == <span class="literal">NULL</span> &amp;&amp; userSize != <span class="number">0</span>)) {
        <span class="comment">// Sanity-check: user is most-likely passing an error code, and it would</span>
        <span class="comment">// make the return value ambiguous (actualSize vs error).</span>
        <span class="keyword">return</span> BAD_VALUE;
    }

    <span class="keyword">size_t</span> written = <span class="number">0</span>;
    Buffer audioBuffer;
    <span class="comment">// 进入循环写，知道userSize写完</span>
    <span class="keyword">while</span> (userSize &gt;= mFrameSize) {
        <span class="comment">// 计算下用户写入的数据 含有多少帧</span>
        audioBuffer.frameCount = userSize / mFrameSize;
        <span class="comment">// 获取buffer空间，blocking默认为true，所以选择ClientProxy::kForever</span>
        <span class="keyword">status_t</span> err = obtainBuffer(&amp;audioBuffer,
                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);
        <span class="comment">// 获取失败</span>
        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) {
            <span class="comment">// 如果之前已经有写入一定的数据，则跳出，否则返回错误的</span>
            <span class="keyword">if</span> (written &gt; <span class="number">0</span>) {
                <span class="keyword">break</span>;
            }
            <span class="keyword">return</span> <span class="keyword">ssize_t</span>(err);
        }
        <span class="comment">// audioBuffer.size记录的是获取到的空间的大小，然后进行数据拷贝，变量更新</span>
        <span class="keyword">size_t</span> toWrite = audioBuffer.size;
        <span class="built_in">memcpy</span>(audioBuffer.i8, buffer, toWrite);
        buffer = ((<span class="keyword">const</span> <span class="keyword">char</span> *) buffer) + toWrite;
        userSize -= toWrite;
        written += toWrite;
        <span class="comment">// 更新下buffer的状态</span>
        releaseBuffer(&amp;audioBuffer);
    }

    <span class="keyword">return</span> written;
}
</code></pre><p><code>write</code>函数主要做了：</p>
<ol>
<li>判断这个track是否可以写</li>
<li>对于direct的track，进行一些flag的消除</li>
<li>开始写，主动去获取写的空间，拷贝数据，更新索引，更新buffer状态，检测是否已经还有数据，如果有继续写，没有的话则返回这次写入的数据长度。</li>
</ol>
<p>这个函数里面有两个重要的函数我们要进一步分析的，一个是<code>obtainBuffer</code>，另一个是<code>releaseBuffer</code>.</p>
<p>先来看<code>obtainBuffer</code></p>
<pre><code><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *requested,
        <span class="keyword">struct</span> timespec *elapsed, <span class="keyword">size_t</span> *nonContig)
{
    <span class="comment">// previous and new IAudioTrack sequence numbers are used to detect track re-creation</span>
    <span class="comment">// 之前和新的sequence用来检测track是否re-creation</span>
    <span class="keyword">uint32_t</span> oldSequence = <span class="number">0</span>;
    <span class="keyword">uint32_t</span> newSequence;

    Proxy::Buffer buffer;
    <span class="keyword">status_t</span> status = NO_ERROR;

    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kMaxTries = <span class="number">5</span>;
    <span class="keyword">int32_t</span> tryCounter = kMaxTries;
    <span class="comment">// 循环的开始</span>
    <span class="keyword">do</span> {
        <span class="comment">// obtainBuffer() is called with mutex unlocked, so keep extra references to these fields to</span>
        <span class="comment">// keep them from going away if another thread re-creates the track during obtainBuffer()</span>
        <span class="comment">// obtainBuffer函数调用必须unlock掉mutex，在此之前有一些参数需要</span>
        sp&lt;AudioTrackClientProxy&gt; proxy;
        sp&lt;IMemory&gt; iMem;

        {   <span class="comment">// start of lock scope</span>
            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;

            newSequence = mSequence;
            <span class="comment">// 是否上一次obtainBuffer失败是由于media server挂掉或者自动放弃治疗？</span>
            <span class="keyword">if</span> (status == DEAD_OBJECT) {
                <span class="comment">// re-create track,除非有人已经做了。</span>
                <span class="keyword">if</span> (newSequence == oldSequence) {
                    <span class="comment">// 会重新createtrack，里面会更新sequence的值</span>
                    status = restoreTrack_l(<span class="string">"obtainBuffer"</span>);
                    <span class="comment">// 一旦restore失败了，则直接跳出来。</span>
                    <span class="keyword">if</span> (status != NO_ERROR) {
                        buffer.mFrameCount = <span class="number">0</span>;
                        buffer.mRaw = <span class="literal">NULL</span>;
                        buffer.mNonContig = <span class="number">0</span>;
                        <span class="keyword">break</span>;
                    }
                }
            }
            <span class="comment">// 更新下sequence</span>
            oldSequence = newSequence;

            <span class="comment">// Keep the extra references</span>
            <span class="comment">// 持有这些额外的引用</span>
            proxy = mProxy;
            iMem = mCblkMemory;
            <span class="comment">// 中途切换成STATE_STOPPING</span>
            <span class="keyword">if</span> (mState == STATE_STOPPING) {
                status = -EINTR;
                buffer.mFrameCount = <span class="number">0</span>;
                buffer.mRaw = <span class="literal">NULL</span>;
                buffer.mNonContig = <span class="number">0</span>;
                <span class="keyword">break</span>;
            }

            <span class="comment">// 如果状态为stoped或者paused的话，将请求设置为non-blocking</span>
            <span class="keyword">if</span> (mState != STATE_ACTIVE) {
                requested = &amp;ClientProxy::kNonBlocking;
            }

        }   <span class="comment">// end of lock scope</span>
        <span class="comment">// 重新组装buffer，传给proxy去获取buffer</span>
        buffer.mFrameCount = audioBuffer-&gt;frameCount;
        <span class="comment">// FIXME starts the requested timeout and elapsed over from scratch</span>
        status = proxy-&gt;obtainBuffer(&amp;buffer, requested, elapsed);
      <span class="comment">// 如果status为DEAD的话，则会等待5次机会，每次都会restore。</span>
    } <span class="keyword">while</span> ((status == DEAD_OBJECT) &amp;&amp; (tryCounter-- &gt; <span class="number">0</span>));
    <span class="comment">// 把获取到的空间数据进行更新到传进来的结构中。</span>
    audioBuffer-&gt;frameCount = buffer.mFrameCount;
    audioBuffer-&gt;size = buffer.mFrameCount * mFrameSize;
    audioBuffer-&gt;raw = buffer.mRaw;
    <span class="keyword">if</span> (nonContig != <span class="literal">NULL</span>) {
        *nonContig = buffer.mNonContig;
    }
    <span class="keyword">return</span> status;
}
</code></pre><p>上面的函数主要实现了：</p>
<ol>
<li>判断IAudioTrack有没有挂掉，如果挂掉的话，进行重新创建</li>
<li>一些对象的引用，不知道目的何在</li>
<li>如果状态切换为STOPPING，则直接退出</li>
<li>如果状态不为ACTIVE，则将请求设置为非阻塞</li>
<li>通过proxy去获取buffer</li>
<li>如果发现track挂掉了，并且次数还没用完则再次循环。</li>
<li>封装数据，返回状态。</li>
</ol>
<p>接下来我们看proxy调用<code>obtainBuffer</code>函数</p>
<pre><code><span class="keyword">status_t</span> ClientProxy::obtainBuffer(Buffer* buffer, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *requested,
        <span class="keyword">struct</span> timespec *elapsed)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>);
    <span class="keyword">struct</span> timespec total;          <span class="comment">// 记录等待所花掉的时间，从当你填满等server消费，通知的时间段</span>
    total.tv_sec = <span class="number">0</span>;
    total.tv_nsec = <span class="number">0</span>;
    <span class="keyword">bool</span> measure = elapsed != <span class="literal">NULL</span>; <span class="comment">// 判断是否需要进行统计时间</span>

    <span class="keyword">status_t</span> status;
    <span class="keyword">enum</span> {
        TIMEOUT_ZERO,       <span class="comment">// requested == NULL || *requested == 0 非阻塞</span>
        TIMEOUT_INFINITE,   <span class="comment">// *requested == infinity 无限等待</span>
        TIMEOUT_FINITE,     <span class="comment">// 0 &lt; *requested &lt; infinity 定时等待</span>
        TIMEOUT_CONTINUE,   <span class="comment">// additional chances after TIMEOUT_FINITE 定时等待的补充</span>
    } timeout;
    <span class="comment">// 默认是阻塞等待，是TIMEOUT_INFINITE</span>
    <span class="keyword">if</span> (requested == <span class="literal">NULL</span>) {
        timeout = TIMEOUT_ZERO;
    } <span class="keyword">else</span> <span class="keyword">if</span> (requested-&gt;tv_sec == <span class="number">0</span> &amp;&amp; requested-&gt;tv_nsec == <span class="number">0</span>) {
        timeout = TIMEOUT_ZERO;
    } <span class="keyword">else</span> <span class="keyword">if</span> (requested-&gt;tv_sec == INT_MAX) {
        timeout = TIMEOUT_INFINITE;
    } <span class="keyword">else</span> {
        timeout = TIMEOUT_FINITE;
        <span class="keyword">if</span> (requested-&gt;tv_sec &gt; <span class="number">0</span> || requested-&gt;tv_nsec &gt;= MEASURE_NS) {
            measure = <span class="literal">true</span>;
        }
    }
    <span class="keyword">struct</span> timespec before;
    <span class="keyword">bool</span> beforeIsValid = <span class="literal">false</span>;
    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
    <span class="keyword">bool</span> ignoreInitialPendingInterrupt = <span class="literal">true</span>;
    <span class="comment">// 检查下share memory是否发生内存脏块，如果有问题，就直接go end</span>
    <span class="keyword">if</span> (mIsShutdown) {
        status = NO_INIT;
        <span class="keyword">goto</span> end;
    }
    <span class="comment">// 无限循环</span>
    <span class="keyword">for</span> (;;) {
        <span class="comment">// 去掉CBLK_INTERRUPT 标志位。并且保存原来的值在flags中</span>
        <span class="keyword">int32_t</span> flags = android_atomic_and(~CBLK_INTERRUPT, &amp;cblk-&gt;mFlags);
        <span class="comment">// 检查server是否将该track认为无效，或者server端挂掉了。</span>
        <span class="keyword">if</span> (flags &amp; CBLK_INVALID) {
            status = DEAD_OBJECT;
            <span class="keyword">goto</span> end;
        }
        <span class="comment">// 检查下obtainBuffer过程是否被client给中断了。第一次不检测，后面都给检测。</span>
        <span class="keyword">if</span> (!ignoreInitialPendingInterrupt &amp;&amp; (flags &amp; CBLK_INTERRUPT)) {
            status = -EINTR;
            <span class="keyword">goto</span> end;
        }
        ignoreInitialPendingInterrupt = <span class="literal">false</span>;
        <span class="comment">// 计算多少帧的空间可以来写，或者多少帧的空间用来读。</span>
        <span class="keyword">int32_t</span> front;
        <span class="keyword">int32_t</span> rear;
        <span class="keyword">if</span> (mIsOut) {
            <span class="comment">// 获取当前填充缓冲区的开头，这个变量是无限递增的</span>
            front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);
            <span class="comment">// 获取当前填充缓冲区的结尾，这个变量是无限递增的。</span>
            rear = cblk-&gt;u.mStreaming.mRear;
        } <span class="keyword">else</span> {
            <span class="comment">// On the other hand, this barrier is required.</span>
            rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);
            front = cblk-&gt;u.mStreaming.mFront;
        }
        <span class="comment">// 计算出当前已经填充的量，就是尚未被消耗的帧。</span>
        <span class="keyword">ssize_t</span> filled = rear - front;
        <span class="comment">// 如果filled的数值不在0到mFrameCount以内，说明内存已经被污染了。</span>
        <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) {
            <span class="keyword">if</span> (mIsOut) {
                <span class="comment">// 设置为shutdown</span>
                mIsShutdown = <span class="literal">true</span>;
                status = NO_INIT;
                <span class="keyword">goto</span> end;
            }
            <span class="comment">// 同步修改下flag添加overrun</span>
            filled = <span class="number">0</span>;
            cblk-&gt;u.mStreaming.mFront = rear;
            (<span class="keyword">void</span>) android_atomic_or(CBLK_OVERRUN, &amp;cblk-&gt;mFlags);
        }
        <span class="comment">// 不允许填充的空间超过管道的大小，如果output的话，则是要填充的，所以是将mFrameCount - </span>
        <span class="comment">// filled， 如果是record，是消费的，所以直接获取filled就行了。</span>
        <span class="keyword">size_t</span> avail = mIsOut ? mFrameCount - filled : filled;
        <span class="comment">// 如果有可写的空间</span>
        <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) {
            <span class="comment">// avail的空间不一定是连续的，可能是后面一节，前面一节，这个时候我们分两次取，先取后面</span>
            <span class="keyword">size_t</span> part1;
            <span class="keyword">if</span> (mIsOut) {
                <span class="comment">// mFrameCountP2这个是mFrameCount的roundup，这边用到了二进制的小技巧，</span>
                <span class="comment">// rear&amp;roundup它的值很好计算。而且真实的空间mFrameCountP2就是这个，只要控制填充量</span>
                <span class="comment">// 不超过mFrameCount就行了。这些变量都是以帧为单位的</span>
                rear &amp;= mFrameCountP2 - <span class="number">1</span>;
                part1 = mFrameCountP2 - rear;
            } <span class="keyword">else</span> {
                front &amp;= mFrameCountP2 - <span class="number">1</span>;
                part1 = mFrameCountP2 - front;
            }
            <span class="comment">// 如果part1 大于avail 那part1只能取到avail，大小我们还是要以mFrameCount的为准的。之</span>
            <span class="comment">// 所以申请mFrameCountP2的空间，完全是为了方便计算。</span>
            <span class="keyword">if</span> (part1 &gt; avail) {
                part1 = avail;
            }
            <span class="comment">// buffer-&gt;mFrameCount这个是用户写过来的数据，如果这个数据比part1还小，那我们只需要分配</span>
            <span class="comment">// 这个空间大小就够了。</span>
            <span class="keyword">if</span> (part1 &gt; buffer-&gt;mFrameCount) {
                part1 = buffer-&gt;mFrameCount;
            }
            <span class="comment">// 重新组装buffer，确定最后分配的空间。</span>
            buffer-&gt;mFrameCount = part1;
            <span class="comment">// 指向的内存空间</span>
            buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?
                    &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? rear : front) * mFrameSize] : <span class="literal">NULL</span>;
            <span class="comment">// 还有多少可用的空间没被使用</span>
            buffer-&gt;mNonContig = avail - part1;
            <span class="comment">// 将申请到的空间大小赋值给mUnreleased，表示尚未被释放，等后面调用release时候，再更新</span>
            mUnreleased = part1;
            status = NO_ERROR;
            <span class="comment">// 如果申请到了空间，那我们就直接跳出这个for循环了。等待write函数中填充好数据在进来获取空</span>
            <span class="comment">// 间。</span>
            <span class="keyword">break</span>;
        }
        <span class="keyword">struct</span> timespec remaining;
        <span class="keyword">const</span> <span class="keyword">struct</span> timespec *ts;
        <span class="keyword">switch</span> (timeout) {
        <span class="keyword">case</span> TIMEOUT_ZERO:
            status = WOULD_BLOCK;
            <span class="keyword">goto</span> end;
        <span class="keyword">case</span> TIMEOUT_INFINITE:
            ts = <span class="literal">NULL</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> TIMEOUT_FINITE:
            <span class="comment">// 被修改成为TIMEOUT_CONTINUE，这边是为了防止平台设置MAX_SEC为0，可以采用自己申请的时间</span>
            <span class="comment">// MAC_SEC表示的是一次所等待的最大时间</span>
            timeout = TIMEOUT_CONTINUE;
            <span class="keyword">if</span> (MAX_SEC == <span class="number">0</span>) {
                ts = requested;
                <span class="keyword">break</span>;
            }
            <span class="comment">// fall through</span>
        <span class="keyword">case</span> TIMEOUT_CONTINUE:
            <span class="comment">// FIXME we do not retry if requested &lt; 10ms? needs documentation on this state machine</span>
            <span class="keyword">if</span> (!measure || requested-&gt;tv_sec &lt; total.tv_sec ||
                    (requested-&gt;tv_sec == total.tv_sec &amp;&amp; requested-&gt;tv_nsec &lt;= total.tv_nsec)) {
                status = TIMED_OUT;
                <span class="keyword">goto</span> end;
            }
            remaining.tv_sec = requested-&gt;tv_sec - total.tv_sec;
            <span class="keyword">if</span> ((remaining.tv_nsec = requested-&gt;tv_nsec - total.tv_nsec) &lt; <span class="number">0</span>) {
                remaining.tv_nsec += <span class="number">1000000000</span>;
                remaining.tv_sec++;
            }
            <span class="comment">// 如果remaining的时间较长，则将强制为MAX_SEC，但是requested的时间并没有减少</span>
            <span class="comment">// 也就是说每次最多等待remaining的长度，知道requested都用光了。</span>
            <span class="keyword">if</span> (<span class="number">0</span> &lt; MAX_SEC &amp;&amp; MAX_SEC &lt; remaining.tv_sec) {
                remaining.tv_sec = MAX_SEC;
                remaining.tv_nsec = <span class="number">0</span>;
            }
            ts = &amp;remaining;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            LOG_ALWAYS_FATAL(<span class="string">"obtainBuffer() timeout=%d"</span>, timeout);
            ts = <span class="literal">NULL</span>;
            <span class="keyword">break</span>;
        }
        <span class="keyword">int32_t</span> old = android_atomic_and(~CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);
        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) {
            <span class="comment">// 定时阻塞的，这边就会进入去记录阻塞之前的时间点。beforeIsValid一开始默认是false</span>
            <span class="comment">// 的。所以肯定进入了这个变量是保证只需要获取一次开始的，因为之后都是以上一次为准的。而且</span>
            <span class="comment">// 这个超时只针对单次超时，为什么不再进来，因为如果第二次到这说明上次也没获取到，时间</span>
            <span class="comment">// 上一致。</span>
            <span class="keyword">if</span> (measure &amp;&amp; !beforeIsValid) {
                clock_gettime(CLOCK_MONOTONIC, &amp;before);
                beforeIsValid = <span class="literal">true</span>;
            }
            errno = <span class="number">0</span>;
            <span class="comment">// 注意，我们阻塞的时候，是有传入ts这个时间的，这个可以保证时间到了自动继续往下运行</span>
            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,
                    mClientInServer ? FUTEX_WAIT_PRIVATE : FUTEX_WAIT, old &amp; ~CBLK_FUTEX_WAKE, ts);
            <span class="comment">// 阻塞结束之后要计算总共消耗时间。</span>
            <span class="keyword">if</span> (measure) {
                <span class="keyword">struct</span> timespec after;
                clock_gettime(CLOCK_MONOTONIC, &amp;after);
                total.tv_sec += after.tv_sec - before.tv_sec;
                <span class="keyword">long</span> deltaNs = after.tv_nsec - before.tv_nsec;
                <span class="keyword">if</span> (deltaNs &lt; <span class="number">0</span>) {
                    deltaNs += <span class="number">1000000000</span>;
                    total.tv_sec--;
                }
                <span class="keyword">if</span> ((total.tv_nsec += deltaNs) &gt;= <span class="number">1000000000</span>) {
                    total.tv_nsec -= <span class="number">1000000000</span>;
                    total.tv_sec++;
                }
                <span class="comment">// 更新下时间点，和beforeIsValid</span>
                before = after;
                beforeIsValid = <span class="literal">true</span>;
            }
            <span class="comment">// 正常唤醒、出错、超时等都会继续在跑循环。</span>
            <span class="keyword">switch</span> (errno) {
            <span class="keyword">case</span> <span class="number">0</span>:            <span class="comment">// normal wakeup by server, or by binderDied()</span>
            <span class="keyword">case</span> EWOULDBLOCK:  <span class="comment">// benign race condition with server</span>
            <span class="keyword">case</span> EINTR:        <span class="comment">// wait was interrupted by signal or other spurious wakeup</span>
            <span class="keyword">case</span> ETIMEDOUT:    <span class="comment">// time-out expired</span>
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                status = errno;
                ALOGE(<span class="string">"%s unexpected error %s"</span>, __func__, strerror(status));
                <span class="keyword">goto</span> end;
            }
        }
    }

end:
    <span class="keyword">if</span> (status != NO_ERROR) {
        buffer-&gt;mFrameCount = <span class="number">0</span>;
        buffer-&gt;mRaw = <span class="literal">NULL</span>;
        buffer-&gt;mNonContig = <span class="number">0</span>;
        mUnreleased = <span class="number">0</span>;
    }
    <span class="keyword">if</span> (elapsed != <span class="literal">NULL</span>) {
        *elapsed = total;
    }
    <span class="keyword">if</span> (requested == <span class="literal">NULL</span>) {
        requested = &amp;kNonBlocking;
    }
    <span class="keyword">if</span> (measure) {
    }
    <span class="keyword">return</span> status;
}
</code></pre><p>这个函数看起来很长，但是其实它做的事情并不多。</p>
<ol>
<li>获取缓冲区</li>
<li>如果获取不到进入阻塞，看情况需要做个计时的。</li>
</ol>
<p>获取缓冲区，这边采用了小技巧。比如用户空间申请的framecount是666个这个是mFrameCount了，那TrackBase那边会给分配1024个这个就是P2了，rear和front都是无限递增的以帧为单位的int类型，它们是以P2为基准的，就是他们是P2的整数倍，这样我们再获取以填充的空间以及剩余可填充的空间就变得很简单了，直接rear-front就是可以填充的空间，剩余的空间就是mFrameCount-filled就可以得到了。</p>
<p>接着就是考虑如何实现循环缓冲了，其实就是引入part1，这个东西，它会让本来只需要填充一次变成需要填充两次，但是却可以简化编程，让逻辑更简单。如果写入的数据比较多，并且剩余的空间包括后面一小部分和前面一部分，那会先把后面这部分填充完，退出，然后让最外面的去release这个已经使用的部分，再来一次获取空间，这次获取的就是拿到前面这部分的缓冲区了。</p>
<p>接下来我们得来看看<code>releaseBuffer</code>的实现了。</p>
<pre><code><span class="keyword">void</span> AudioTrack::releaseBuffer(<span class="keyword">const</span> Buffer* audioBuffer)
{
    <span class="comment">// mTransfer不能为TRANSFER_SHARED</span>
    <span class="keyword">if</span> (mTransfer == TRANSFER_SHARED) {
        <span class="keyword">return</span>;
    }
    <span class="comment">// 计算这次填充的空间，转换成帧</span>
    <span class="keyword">size_t</span> stepCount = audioBuffer-&gt;size / mFrameSize;
    <span class="keyword">if</span> (stepCount == <span class="number">0</span>) {
        <span class="keyword">return</span>;
    }

    Proxy::Buffer buffer;
    buffer.mFrameCount = stepCount;
    buffer.mRaw = audioBuffer-&gt;raw;

    <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;
    <span class="comment">// release做累加</span>
    mReleased += stepCount;
    mInUnderrun = <span class="literal">false</span>;
    <span class="comment">// 调用proxy的releaseBuffer</span>
    mProxy-&gt;releaseBuffer(&amp;buffer);

    <span class="comment">// 重启track 如果之前被AudioFlinger因为underrun给disable了</span>
    <span class="keyword">if</span> (mState == STATE_ACTIVE) {
        <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
        <span class="keyword">if</span> (android_atomic_and(~CBLK_DISABLED, &amp;cblk-&gt;mFlags) &amp; CBLK_DISABLED) {
            mAudioTrack-&gt;start();
        }
    }
}
</code></pre><p>上面的函数，做个统计，然后就调用proxy的releaseBuffer了。</p>
<pre><code><span class="literal">void</span> ClientProxy<span class="tag">::releaseBuffer</span>(Buffer* buffer)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="built_in">NULL</span>);
    size_t stepCount = buffer<span class="subst">-&gt;</span>mFrameCount;
    <span class="keyword">if</span> (stepCount == <span class="number">0</span> <span class="subst">||</span> mIsShutdown) {
        <span class="comment">// prevent accidental re-use of buffer</span>
        buffer<span class="subst">-&gt;</span>mFrameCount = <span class="number">0</span>;
        buffer<span class="subst">-&gt;</span>mRaw = <span class="built_in">NULL</span>;
        buffer<span class="subst">-&gt;</span>mNonContig = <span class="number">0</span>;
        <span class="keyword">return</span>;
    }
    <span class="comment">// 更新下mUnreleased的值。表示还有多少分配给client的空间未被填充。</span>
    mUnreleased -= stepCount;
    audio_track_cblk_t* cblk = mCblk;
    <span class="comment">// 更新下缓冲区的index。这边可以看出rear和front是一个一直递增的值。</span>
    <span class="keyword">if</span> (mIsOut) {
        int32_t rear = cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mRear;
        android_atomic_release_store(stepCount + rear, <span class="subst">&amp;</span>cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mRear);
    } <span class="keyword">else</span> {
        int32_t front = cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mFront;
        android_atomic_release_store(stepCount + front, <span class="subst">&amp;</span>cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mFront);
    }
}
</code></pre><h3 id="消费者部分">消费者部分</h3><p>前面我们有提到，消费者是一个线程，这个线程，在我们当前这个场景下是一个普通的mixer thread，其实也是我们前面一直有出现的output thread，这个线程主要就是负责获取数据，mix数据，效果处理等一系列的操作的。每一个普通的mixer thread，它都可能会包含好多个的track，这样的话，它的实现上必然就不能为等待某个track的数据而发生阻塞，只有当所有的track都没数据了，它才会进入休眠状态。<br>当然这边我们讲解的主要场景是获取数据了，获取数据其实是在AudioMixer里面来执行的，但是我们不能只关注获取，我们需要关注的是流程如何控制到获取数据的整个逻辑。所以我们从<code>MixerThread::prepareTracks_l</code>，这边我会先把fast track相关的部分先省略掉，因为我们目前只定位在normal track，其实fast track的逻辑也是差不多的，只是细节实现上更复杂一些。</p>
<pre><code>AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l(
        Vector&lt; sp&lt;Track&gt; &gt; *tracksToRemove)
{

    mixer_state mixerStatus = MIXER_IDLE;
    <span class="comment">// 看有多少个track需要被处理的</span>
    size_t count = mActiveTracks.size();
    size_t mixedTracks = <span class="number">0</span>;
    size_t tracksWithEffect = <span class="number">0</span>;

    <span class="keyword">float</span> masterVolume = mMasterVolume;
    <span class="keyword">bool</span> masterMute = mMasterMute;

    <span class="keyword">if</span> (masterMute) {
        masterVolume = <span class="number">0</span>;
    }
    <span class="comment">// 如果存在全局音效的话，委托全局音效来控制master volume。</span>
    sp&lt;EffectChain&gt; chain = getEffectChain_l(AUDIO_SESSION_OUTPUT_MIX);
    <span class="keyword">if</span> (chain != <span class="number">0</span>) {
        uint32_t v = (uint32_t)(masterVolume * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>));
        chain-&gt;setVolume_l(&amp;v, &amp;v);
        masterVolume = (<span class="keyword">float</span>)((v + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>)) &gt;&gt; <span class="number">24</span>);
        chain.clear();
    }

    mMixerBufferValid = <span class="keyword">false</span>;  <span class="comment">// 有使用mixerbuffer的tracks被找到并且有数据会被置为true</span>
    mEffectBufferValid = <span class="keyword">false</span>; <span class="comment">// 有使用mixerbuffer的tracks被找到并且有数据会被置为true</span>

    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) {
        <span class="keyword">const</span> sp&lt;Track&gt; t = mActiveTracks[i].promote();
        <span class="keyword">if</span> (t == <span class="number">0</span>) {
            <span class="keyword">continue</span>;
        }

        Track* <span class="keyword">const</span> track = t.get();

        {   <span class="comment">// local variable scope to avoid goto warning</span>

        audio_track_cblk_t* cblk = track-&gt;cblk();

        <span class="comment">// 对于第一次被添加进来的track，我们会等待它把buffer都填充满才来处理的。</span>
        <span class="keyword">int</span> name = track-&gt;name();
        <span class="comment">// make sure that we have enough frames to mix one full buffer.</span>
        <span class="comment">// enforce this condition only once to enable draining the buffer in case the client</span>
        <span class="comment">// app does not call stop() and relies on underrun to stop:</span>
        <span class="comment">// hence the test on (mMixerStatus == MIXER_TRACKS_READY) meaning the track was mixed</span>
        <span class="comment">// during last round</span>
        size_t desiredFrames;
        <span class="keyword">const</span> uint32_t sampleRate = track-&gt;mAudioTrackServerProxy-&gt;getSampleRate();
        AudioPlaybackRate playbackRate = track-&gt;mAudioTrackServerProxy-&gt;getPlaybackRate();
        <span class="comment">// 计算hal层buffer映射到当前速率，采样率下是多少帧</span>
        desiredFrames = sourceFramesNeededWithTimestretch(
                sampleRate, mNormalFrameCount, mSampleRate, playbackRate.mSpeed);
        <span class="comment">// <span class="doctag">TODO:</span> ONLY USED FOR LEGACY RESAMPLERS, remove when they are removed.</span>
        <span class="comment">// add frames already consumed but not yet released by the resampler</span>
        <span class="comment">// because mAudioTrackServerProxy-&gt;framesReady() will include these frames</span>
        desiredFrames += mAudioMixer-&gt;getUnreleasedFrames(track-&gt;name());

        uint32_t minFrames = <span class="number">1</span>;
        <span class="comment">// 如果上一次是已经ready的，则这次才会更新minFrames，否则依然是1</span>
        <span class="keyword">if</span> ((track-&gt;sharedBuffer() == <span class="number">0</span>) &amp;&amp; !track-&gt;isStopped() &amp;&amp; !track-&gt;isPausing() &amp;&amp;
                (mMixerStatusIgnoringFastTracks == MIXER_TRACKS_READY)) {
            minFrames = desiredFrames;
        }

        size_t framesReady = track-&gt;framesReady();

        <span class="keyword">if</span> ((framesReady &gt;= minFrames) &amp;&amp; track-&gt;isReady() &amp;&amp;
                !track-&gt;isPaused() &amp;&amp; !track-&gt;isTerminated())
        {
            mixedTracks++;

            <span class="comment">// track-&gt;mainBuffer() != mSinkBuffer or mMixerBuffer means</span>
            <span class="comment">// there is an effect chain connected to the track</span>
            chain.clear();
            <span class="keyword">if</span> (track-&gt;mainBuffer() != mSinkBuffer &amp;&amp;
                    track-&gt;mainBuffer() != mMixerBuffer) {
                <span class="keyword">if</span> (mEffectBufferEnabled) {
                    mEffectBufferValid = <span class="keyword">true</span>; <span class="comment">// Later can set directly.</span>
                }
                chain = getEffectChain_l(track-&gt;sessionId());
                <span class="comment">// Delegate volume control to effect in track effect chain if needed</span>
                <span class="keyword">if</span> (chain != <span class="number">0</span>) {
                    tracksWithEffect++;
                } <span class="keyword">else</span> {
                }
            }

            <span class="keyword">int</span> param = AudioMixer::VOLUME;
            <span class="keyword">if</span> (track-&gt;mFillingUpStatus == Track::FS_FILLED) {
                <span class="comment">// no ramp for the first volume setting</span>
                track-&gt;mFillingUpStatus = Track::FS_ACTIVE;
                <span class="keyword">if</span> (track-&gt;mState == TrackBase::RESUMING) {
                    track-&gt;mState = TrackBase::ACTIVE;
                    param = AudioMixer::RAMP_VOLUME;
                }
                mAudioMixer-&gt;setParameter(name, AudioMixer::RESAMPLE, AudioMixer::RESET, <span class="keyword">NULL</span>);
            <span class="comment">// FIXME should not make a decision based on mServer</span>
            } <span class="keyword">else</span> <span class="keyword">if</span> (cblk-&gt;mServer != <span class="number">0</span>) {
                <span class="comment">// If the track is stopped before the first frame was mixed,</span>
                <span class="comment">// do not apply ramp</span>
                param = AudioMixer::RAMP_VOLUME;
            }

            <span class="comment">// compute volume for this track</span>
            uint32_t vl, vr;       <span class="comment">// in U8.24 integer format</span>
            <span class="keyword">float</span> vlf, vrf, vaf;   <span class="comment">// in [0.0, 1.0] float format</span>
            <span class="keyword">if</span> (track-&gt;isPausing() || mStreamTypes[track-&gt;streamType()].mute) {
                vl = vr = <span class="number">0</span>;
                vlf = vrf = vaf = <span class="number">0.</span>;
                <span class="keyword">if</span> (track-&gt;isPausing()) {
                    track-&gt;setPaused();
                }
            } <span class="keyword">else</span> {

                <span class="comment">// read original volumes with volume control</span>
                <span class="keyword">float</span> typeVolume = mStreamTypes[track-&gt;streamType()].volume;
                <span class="keyword">float</span> v = masterVolume * typeVolume;
                AudioTrackServerProxy *proxy = track-&gt;mAudioTrackServerProxy;
                gain_minifloat_packed_t vlr = proxy-&gt;getVolumeLR();
                vlf = float_from_gain(gain_minifloat_unpack_left(vlr));
                vrf = float_from_gain(gain_minifloat_unpack_right(vlr));
                <span class="comment">// track volumes come from shared memory, so can't be trusted and must be clamped</span>
                <span class="keyword">if</span> (vlf &gt; GAIN_FLOAT_UNITY) {
                    vlf = GAIN_FLOAT_UNITY;
                }
                <span class="keyword">if</span> (vrf &gt; GAIN_FLOAT_UNITY) {
                    vrf = GAIN_FLOAT_UNITY;
                }
                <span class="comment">// now apply the master volume and stream type volume</span>
                vlf *= v;
                vrf *= v;
                <span class="comment">// assuming master volume and stream type volume each go up to 1.0,</span>
                <span class="comment">// then derive vl and vr as U8.24 versions for the effect chain</span>
                <span class="keyword">const</span> <span class="keyword">float</span> scaleto8_24 = MAX_GAIN_INT * MAX_GAIN_INT;
                vl = (uint32_t) (scaleto8_24 * vlf);
                vr = (uint32_t) (scaleto8_24 * vrf);
                <span class="comment">// vl and vr are now in U8.24 format</span>
                uint16_t sendLevel = proxy-&gt;getSendLevel_U4_12();
                <span class="comment">// send level comes from shared memory and so may be corrupt</span>
                <span class="keyword">if</span> (sendLevel &gt; MAX_GAIN_INT) {
                    ALOGV(<span class="string">"Track send level out of range: %04X"</span>, sendLevel);
                    sendLevel = MAX_GAIN_INT;
                }
                <span class="comment">// vaf is represented as [0.0, 1.0] float by rescaling sendLevel</span>
                vaf = v * sendLevel * (<span class="number">1.</span> / MAX_GAIN_INT);
            }

            <span class="comment">// Delegate volume control to effect in track effect chain if needed</span>
            <span class="keyword">if</span> (chain != <span class="number">0</span> &amp;&amp; chain-&gt;setVolume_l(&amp;vl, &amp;vr)) {
                <span class="comment">// Do not ramp volume if volume is controlled by effect</span>
                param = AudioMixer::VOLUME;
                <span class="comment">// Update remaining floating point volume levels</span>
                vlf = (<span class="keyword">float</span>)vl / (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);
                vrf = (<span class="keyword">float</span>)vr / (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);
                track-&gt;mHasVolumeController = <span class="keyword">true</span>;
            } <span class="keyword">else</span> {
                <span class="comment">// force no volume ramp when volume controller was just disabled or removed</span>
                <span class="comment">// from effect chain to avoid volume spike</span>
                <span class="keyword">if</span> (track-&gt;mHasVolumeController) {
                    param = AudioMixer::VOLUME;
                }
                track-&gt;mHasVolumeController = <span class="keyword">false</span>;
            }

            <span class="comment">// <span class="doctag">XXX:</span> these things DON'T need to be done each time</span>
            mAudioMixer-&gt;setBufferProvider(name, track);
            mAudioMixer-&gt;enable(name);

            mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME0, &amp;vlf);
            mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME1, &amp;vrf);
            mAudioMixer-&gt;setParameter(name, param, AudioMixer::AUXLEVEL, &amp;vaf);
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::FORMAT, (void *)track-&gt;format());
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::CHANNEL_MASK, (void *)(uintptr_t)track-&gt;channelMask());
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::MIXER_CHANNEL_MASK, (void *)(uintptr_t)mChannelMask);
            <span class="comment">// limit track sample rate to 2 x output sample rate, which changes at re-configuration</span>
            uint32_t maxSampleRate = mSampleRate * AUDIO_RESAMPLER_DOWN_RATIO_MAX;
            uint32_t reqSampleRate = track-&gt;mAudioTrackServerProxy-&gt;getSampleRate();
            <span class="keyword">if</span> (reqSampleRate == <span class="number">0</span>) {
                reqSampleRate = mSampleRate;
            } <span class="keyword">else</span> <span class="keyword">if</span> (reqSampleRate &gt; maxSampleRate) {
                reqSampleRate = maxSampleRate;
            }
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::RESAMPLE,
                AudioMixer::SAMPLE_RATE,
                (void *)(uintptr_t)reqSampleRate);

            AudioPlaybackRate playbackRate = track-&gt;mAudioTrackServerProxy-&gt;getPlaybackRate();
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TIMESTRETCH,
                AudioMixer::PLAYBACK_RATE,
                &amp;playbackRate);

            <span class="comment">/*
             * Select the appropriate output buffer for the track.
             *
             * Tracks with effects go into their own effects chain buffer
             * and from there into either mEffectBuffer or mSinkBuffer.
             *
             * Other tracks can use mMixerBuffer for higher precision
             *  .  If this buffer is enabled
             * (mMixerBufferEnabled true), then selected tracks will accumulate
             * into it.
             *
             */</span>
            <span class="comment">// 选择合适的output buffer。添加了effect的track将会把数据输出到效果链的buffer中</span>
            <span class="comment">// 处理完之后会输出到没EffectBuffer或者mSinkBuffer中</span>
            <span class="comment">// 其他track使用mMixerBuffer，可以用来高精度的累加</span>
            <span class="keyword">if</span> (mMixerBufferEnabled
                    &amp;&amp; (track-&gt;mainBuffer() == mSinkBuffer
                            || track-&gt;mainBuffer() == mMixerBuffer)) {
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MIXER_FORMAT, (void *)mMixerBufferFormat);
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MAIN_BUFFER, (void *)mMixerBuffer);
                <span class="comment">// <span class="doctag">TODO:</span> override track-&gt;mainBuffer()?</span>
                mMixerBufferValid = <span class="keyword">true</span>;
            } <span class="keyword">else</span> {
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MIXER_FORMAT, (void *)AUDIO_FORMAT_PCM_16_BIT);
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MAIN_BUFFER, (void *)track-&gt;mainBuffer());
            }
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::AUX_BUFFER, (void *)track-&gt;auxBuffer());

            <span class="comment">// reset retry count</span>
            track-&gt;mRetryCount = kMaxTrackRetries;

            <span class="comment">// If one track is ready, set the mixer ready if:</span>
            <span class="comment">//  - the mixer was not ready during previous round OR</span>
            <span class="comment">//  - no other track is not ready</span>
            <span class="comment">// 如果上一次没有ready，这次只要有一个track已经ready，则为ready</span>
            <span class="keyword">if</span> (mMixerStatusIgnoringFastTracks != MIXER_TRACKS_READY ||
                    mixerStatus != MIXER_TRACKS_ENABLED) {
                mixerStatus = MIXER_TRACKS_READY;
            }
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (framesReady &lt; desiredFrames &amp;&amp; !track-&gt;isStopped() &amp;&amp; !track-&gt;isPaused()) {
                track-&gt;mAudioTrackServerProxy-&gt;tallyUnderrunFrames(desiredFrames);
            }
            <span class="comment">// clear effect chain input buffer if an active track underruns to avoid sending</span>
            <span class="comment">// previous audio buffer again to effects</span>
            chain = getEffectChain_l(track-&gt;sessionId());
            <span class="keyword">if</span> (chain != <span class="number">0</span>) {
                chain-&gt;clearInputBuffer();
            }
            <span class="comment">// 如果track是使用共享内存，或者已经终止、停止、暂停，则会进入下面逻辑。 </span>
            <span class="keyword">if</span> ((track-&gt;sharedBuffer() != <span class="number">0</span>) || track-&gt;isTerminated() ||
                    track-&gt;isStopped() || track-&gt;isPaused()) {
                <span class="comment">// We have consumed all the buffers of this track.</span>
                <span class="comment">// Remove it from the list of active tracks.</span>
                <span class="comment">// <span class="doctag">TODO:</span> use actual buffer filling status instead of latency when available from</span>
                <span class="comment">// audio HAL</span>
                size_t audioHALFrames = (latency_l() * mSampleRate) / <span class="number">1000</span>;
                size_t framesWritten = mBytesWritten / mFrameSize;
                <span class="keyword">if</span> (mStandby || track-&gt;presentationComplete(framesWritten, audioHALFrames)) {
                    <span class="keyword">if</span> (track-&gt;isStopped()) {
                        track-&gt;reset();
                    }
                    tracksToRemove-&gt;add(track);
                }
            } <span class="keyword">else</span> {
                <span class="comment">// 如果不是共享内存，并且当前状态不是终止、停止、暂停，就说明肯定就是数据给的不够。</span>
                <span class="comment">// 这个时候会给它50次的机会进行填充，如果还不满足就移掉active list了。</span>
                <span class="keyword">if</span> (--(track-&gt;mRetryCount) &lt;= <span class="number">0</span>) {
                    tracksToRemove-&gt;add(track);
                    <span class="comment">// 告诉app的track由于underrun被disable，如果数据够，会自动调用start()方法</span>
                    android_atomic_or(CBLK_DISABLED, &amp;cblk-&gt;mFlags);
                <span class="comment">// 只要有一个active track尚未ready，那就标志mixer states为not ready</span>
                <span class="comment">// 但是这边有个例外的，上一次已经设置为enable，并且有两个track，一个ready，另外</span>
                <span class="comment">// 一个not ready，则这次的mixer states会被设置为READY</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (mMixerStatusIgnoringFastTracks == MIXER_TRACKS_READY ||
                                mixerStatus != MIXER_TRACKS_READY) {
                    mixerStatus = MIXER_TRACKS_ENABLED;
                }
            }
            <span class="comment">// 这边会将AudioMixer disable。</span>
            mAudioMixer-&gt;disable(name);
        }

        }   <span class="comment">// local variable scope to avoid goto warning</span>
track_is_ready: ;

    }

    <span class="comment">// Push the new FastMixer state if necessary</span>
    <span class="keyword">bool</span> pauseAudioWatchdog = <span class="keyword">false</span>;
<span class="comment">#ifdef AUDIO_WATCHDOG</span>
    <span class="keyword">if</span> (pauseAudioWatchdog &amp;&amp; mAudioWatchdog != <span class="number">0</span>) {
        mAudioWatchdog-&gt;pause();
    }
<span class="comment">#endif</span>

    <span class="comment">// remove all the tracks that need to be...</span>
    removeTracks_l(*tracksToRemove);

    <span class="keyword">if</span> (getEffectChain_l(AUDIO_SESSION_OUTPUT_MIX) != <span class="number">0</span>) {
        mEffectBufferValid = <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (mEffectBufferValid) {
        <span class="comment">// as long as there are effects we should clear the effects buffer, to avoid</span>
        <span class="comment">// passing a non-clean buffer to the effect chain</span>
        memset(mEffectBuffer, <span class="number">0</span>, mEffectBufferSize);
    }
    <span class="comment">// sink or mix buffer must be cleared if all tracks are connected to an</span>
    <span class="comment">// effect chain as in this case the mixer will not write to the sink or mix buffer</span>
    <span class="comment">// and track effects will accumulate into it</span>
    <span class="comment">// Motorola, IKXREL1KK-2809 The mix buffer could be used even not all tracks are</span>
    <span class="comment">// connected to an effect chain. So remove the check (mixedTracks == tracksWithEffect).</span>
    <span class="keyword">if</span> ((mBytesRemaining == <span class="number">0</span>) &amp;&amp; ((mixedTracks != <span class="number">0</span>) ||
    <span class="comment">// END IKXREL1KK-2809</span>
            (mixedTracks == <span class="number">0</span> &amp;&amp; fastTracks &gt; <span class="number">0</span>))) {
        <span class="comment">// FIXME as a performance optimization, should remember previous zero status</span>
        <span class="keyword">if</span> (mMixerBufferValid) {
            memset(mMixerBuffer, <span class="number">0</span>, mMixerBufferSize);
            <span class="comment">// <span class="doctag">TODO:</span> In testing, mSinkBuffer below need not be cleared because</span>
            <span class="comment">// the PlaybackThread::threadLoop() copies mMixerBuffer into mSinkBuffer</span>
            <span class="comment">// after mixing.</span>
            <span class="comment">//</span>
            <span class="comment">// To enforce this guarantee:</span>
            <span class="comment">// ((mixedTracks != 0 &amp;&amp; mixedTracks == tracksWithEffect) ||</span>
            <span class="comment">// (mixedTracks == 0 &amp;&amp; fastTracks &gt; 0))</span>
            <span class="comment">// must imply MIXER_TRACKS_READY.</span>
            <span class="comment">// Later, we may clear buffers regardless, and skip much of this logic.</span>
        }
        <span class="comment">// FIXME as a performance optimization, should remember previous zero status</span>
        memset(mSinkBuffer, <span class="number">0</span>, mNormalFrameCount * mFrameSize);
    }

    <span class="comment">// if any fast tracks, then status is ready</span>
    mMixerStatusIgnoringFastTracks = mixerStatus;
    <span class="keyword">if</span> (fastTracks &gt; <span class="number">0</span>) {
        mixerStatus = MIXER_TRACKS_READY;
    }
    <span class="keyword">return</span> mixerStatus;
}
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag">#Android</a>
          
            <a href="/tags/AudioTrack/" rel="tag">#AudioTrack</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/18/audiotrack_play/" rel="next" title="audiotrack的play流程">
                <i class="fa fa-chevron-left"></i> audiotrack的play流程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/18/audiotrack_write/"
           data-title="audiotrack的write流程" data-url="http://thinks.me/2016/03/18/audiotrack_write/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="LexiMee" />
          <p class="site-author-name" itemprop="name">LexiMee</p>
          <p class="site-description motion-element" itemprop="description">leave me alone</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者部分"><span class="nav-number">2.1.</span> <span class="nav-text">生产者部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者部分"><span class="nav-number">2.2.</span> <span class="nav-text">消费者部分</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LexiMee</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"thinks"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>

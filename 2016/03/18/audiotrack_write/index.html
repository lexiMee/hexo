<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,AudioTrack," />





  <link rel="alternate" href="/atom.xml" title="Thinking" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">
<meta property="og:type" content="article">
<meta property="og:title" content="audiotrack的write流程">
<meta property="og:url" content="http://thinks.me/2016/03/18/audiotrack_write/index.html">
<meta property="og:site_name" content="Thinking">
<meta property="og:description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">
<meta property="og:updated_time" content="2016-03-20T07:43:30.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="audiotrack的write流程">
<meta name="twitter:description" content="简述到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。
读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：

生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> audiotrack的write流程 | Thinking </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?1a17ff812788f97b5ec90bee6eba907f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Thinking</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                audiotrack的write流程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T14:23:24+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android开发/" itemprop="url" rel="index">
                    <span itemprop="name">android开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/18/audiotrack_write/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/18/audiotrack_write/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="简述">简述</h2><p>到目前为止，我们已经完成了audiotrack创建和设置，它完成了cblk、clientproxy、serverproxy、track、output等的创建和关联，并且打开了音频通路，紧接着就等我们写数据了。</p>
<p>读写数据的操作是一个生产者和消费者的逻辑。这边的逻辑是这样的：</p>
<blockquote>
<p>生产者写数据，线程消费数据，线程消费了n个数据之后，发现已经完成minbuffersize的消费，会去通知你继续填充数据。它们是在两个独立的线程里面的。</p>
</blockquote>
<p>所以可能会出现三种情况的数据填写：</p>
<ol>
<li>生产者极快。生产者数据写完了，等待消费者消费到minbuffersize，然后唤醒生产者继续填充，在消费者进行下次消费之前已经填充完，又进入等待。看起来好像是有序的填充，等待，消费，唤醒，填充，等待，消费，唤醒的线性逻辑</li>
<li>生产和消费速度相当。生产者数据写完了，等待消费者消费到minbuffersize，然后唤醒生产者继续填充，生产者的生产速度极慢，每次填充都正好满足消费者的。这边看起来就是异步的了，一边一直在填充、一边一直在消费，基本上没有唤醒情况</li>
<li>生产速度远远小于消费速度。生产者的数据写入太慢，消费者消费过快，这个时候就会出现underrun了，这个时候消费者会给生产者一定的机会，如果还是没能够给到数据，则就将其赶出判断的行列。</li>
</ol>
<a id="more"></a>
<h2 id="正文">正文</h2><h3 id="生产者部分">生产者部分</h3><p>从java开始看，我们平常调用的不指定是否阻塞，默认就是阻塞的。</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(@NonNull <span class="keyword">short</span>[] audioData, <span class="keyword">int</span> offsetInShorts, <span class="keyword">int</span> sizeInShorts)</span> </span>{
    <span class="keyword">return</span> write(audioData, offsetInShorts, sizeInShorts, WRITE_BLOCKING);
}
<span class="comment">// 这边有个需要注意的是，传入的数据所存放的buffer是类型的，比如byte的话，则format不可以为float类型</span>
<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(@NonNull byte[] audioData, <span class="keyword">int</span> offsetInBytes, <span class="keyword">int</span> sizeInBytes,
        @WriteMode <span class="keyword">int</span> writeMode)</span> </span>{
    <span class="comment">// 必须已经经过初始化了，并且对format有限制，因为传入的数组是一个byte类型</span>
    <span class="keyword">if</span> (mState == STATE_UNINITIALIZED || mAudioFormat == AudioFormat.ENCODING_PCM_FLOAT) {
        <span class="keyword">return</span> ERROR_INVALID_OPERATION;
    }
    <span class="comment">// writeMode只有两种情况，一种是blocking，另外一种是non blocking</span>
    <span class="keyword">if</span> ((writeMode != WRITE_BLOCKING) &amp;&amp; (writeMode != WRITE_NON_BLOCKING)) {
        <span class="keyword">return</span> ERROR_BAD_VALUE;
    }

    <span class="keyword">if</span> ( (audioData == null) || (offsetInBytes &lt; <span class="number">0</span> ) || (sizeInBytes &lt; <span class="number">0</span>)
            || (offsetInBytes + sizeInBytes &lt; <span class="number">0</span>)    <span class="comment">// detect integer overflow</span>
            || (offsetInBytes + sizeInBytes &gt; audioData.length)) {
        <span class="keyword">return</span> ERROR_BAD_VALUE;
    }

    <span class="keyword">int</span> ret = native_write_byte(audioData, offsetInBytes, sizeInBytes, mAudioFormat,
            writeMode == WRITE_BLOCKING);

    <span class="keyword">if</span> ((mDataLoadMode == MODE_STATIC)
            &amp;&amp; (mState == STATE_NO_STATIC_DATA)
            &amp;&amp; (ret &gt; <span class="number">0</span>)) {
        <span class="comment">// benign race with respect to other APIs that read mState</span>
        mState = STATE_INITIALIZED;
    }

    <span class="keyword">return</span> ret;
}
</code></pre><p>上面函数做了下常规检查，然后就调用native的函数进行执行写的操作了。</p>
<p>看下函数实现<code>native_write_byte</code></p>
<pre><code><span class="function"><span class="keyword">static</span> jint <span class="title">android_media_AudioTrack_write_native_bytes</span><span class="params">(JNIEnv *env,  jobject thiz,
        jbyteArray javaBytes, jint byteOffset, jint sizeInBytes,
        jint javaAudioFormat, jboolean isWriteBlocking)</span> </span>{

    sp&lt;AudioTrack&gt; lpTrack = getAudioTrack(env, thiz);
    <span class="keyword">if</span> (lpTrack == <span class="literal">NULL</span>) {
        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>,
                <span class="string">"Unable to retrieve AudioTrack pointer for write()"</span>);
        <span class="keyword">return</span> (jint)AUDIO_JAVA_INVALID_OPERATION;
    }

    <span class="function">ScopedBytesRO <span class="title">bytes</span><span class="params">(env, javaBytes)</span></span>;
    <span class="keyword">if</span> (bytes.get() == <span class="literal">NULL</span>) {
        <span class="keyword">return</span> (jint)AUDIO_JAVA_BAD_VALUE;
    }
    <span class="comment">// 调用writeToTrack执行写的操作</span>
    jint written = writeToTrack(lpTrack, javaAudioFormat, bytes.get(), byteOffset,
            sizeInBytes, isWriteBlocking == JNI_TRUE <span class="comment">/* blocking */</span>);

    <span class="keyword">return</span> written;
}

<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="function"><span class="keyword">static</span> jint <span class="title">writeToTrack</span><span class="params">(<span class="keyword">const</span> sp&lt;AudioTrack&gt;&amp; track, jint audioFormat, <span class="keyword">const</span> T *data,
                         jint offsetInSamples, jint sizeInSamples, <span class="keyword">bool</span> blocking)</span> </span>{
    <span class="comment">// give the data to the native AudioTrack object (the data starts at the offset)</span>
    <span class="keyword">ssize_t</span> written = <span class="number">0</span>;
    <span class="comment">// regular write() or copy the data to the AudioTrack's shared memory?</span>
    <span class="keyword">size_t</span> sizeInBytes = <span class="function">sizeInSamples * <span class="title">sizeof</span><span class="params">(T)</span></span>;
    <span class="comment">// 如果非share memory的话，直接调用audiotrack的write函数</span>
    <span class="keyword">if</span> (track-&gt;sharedBuffer() == <span class="number">0</span>) {
        written = track-&gt;write(data + offsetInSamples, sizeInBytes, blocking);
        <span class="comment">// for compatibility with earlier behavior of write(), return 0 in this case</span>
        <span class="keyword">if</span> (written == (<span class="keyword">ssize_t</span>) WOULD_BLOCK) {
            written = <span class="number">0</span>;
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 写到share memory，检查下容量</span>
        <span class="comment">// writing to shared memory, check for capacity</span>
        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)sizeInBytes &gt; track-&gt;sharedBuffer()-&gt;size()) {
            sizeInBytes = track-&gt;sharedBuffer()-&gt;size();
        }
        <span class="comment">// 直接进行拷贝</span>
        <span class="built_in">memcpy</span>(track-&gt;sharedBuffer()-&gt;pointer(), data + offsetInSamples, sizeInBytes);
        written = sizeInBytes;
    }
    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) {
        <span class="keyword">return</span> written / <span class="keyword">sizeof</span>(T);
    }
    <span class="comment">// for compatibility, error codes pass through unchanged</span>
    <span class="keyword">return</span> written;
}
</code></pre><p>上面的函数只是简单进行write的操作，我们现在进入主体函数。</p>
<pre><code><span class="keyword">ssize_t</span> AudioTrack::write(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> userSize, <span class="keyword">bool</span> blocking)
{
    <span class="comment">// 该write函数要求mTransfer必须为TRANSFER_SYNC并且不是timetrack</span>
    <span class="keyword">if</span> (mTransfer != TRANSFER_SYNC || mIsTimed) {
        <span class="keyword">return</span> INVALID_OPERATION;
    }
    <span class="comment">// 判断下flag中是否带有direct flag，如果是flag，则去掉CBLK_UNDERRUN、CBLK_LOOP_CYCLE</span>
    <span class="comment">// CBLK_LOOP_FINAL、CBLK_BUFFER_END</span>
    <span class="keyword">if</span> (isDirect()) {
        <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;
        <span class="keyword">int32_t</span> flags = android_atomic_and(
                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),
                            &amp;mCblk-&gt;mFlags);
        <span class="comment">// 如果此时flag还含有CBLK_INVALID flag</span>
        <span class="keyword">if</span> (flags &amp; CBLK_INVALID) {
            <span class="keyword">return</span> DEAD_OBJECT;
        }
    }

    <span class="keyword">if</span> (<span class="keyword">ssize_t</span>(userSize) &lt; <span class="number">0</span> || (buffer == <span class="literal">NULL</span> &amp;&amp; userSize != <span class="number">0</span>)) {
        <span class="comment">// Sanity-check: user is most-likely passing an error code, and it would</span>
        <span class="comment">// make the return value ambiguous (actualSize vs error).</span>
        <span class="keyword">return</span> BAD_VALUE;
    }

    <span class="keyword">size_t</span> written = <span class="number">0</span>;
    Buffer audioBuffer;
    <span class="comment">// 进入循环写，知道userSize写完</span>
    <span class="keyword">while</span> (userSize &gt;= mFrameSize) {
        <span class="comment">// 计算下用户写入的数据 含有多少帧</span>
        audioBuffer.frameCount = userSize / mFrameSize;
        <span class="comment">// 获取buffer空间，blocking默认为true，所以选择ClientProxy::kForever</span>
        <span class="keyword">status_t</span> err = obtainBuffer(&amp;audioBuffer,
                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);
        <span class="comment">// 获取失败</span>
        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) {
            <span class="comment">// 如果之前已经有写入一定的数据，则跳出，否则返回错误的</span>
            <span class="keyword">if</span> (written &gt; <span class="number">0</span>) {
                <span class="keyword">break</span>;
            }
            <span class="keyword">return</span> <span class="keyword">ssize_t</span>(err);
        }
        <span class="comment">// audioBuffer.size记录的是获取到的空间的大小，然后进行数据拷贝，变量更新</span>
        <span class="keyword">size_t</span> toWrite = audioBuffer.size;
        <span class="built_in">memcpy</span>(audioBuffer.i8, buffer, toWrite);
        buffer = ((<span class="keyword">const</span> <span class="keyword">char</span> *) buffer) + toWrite;
        userSize -= toWrite;
        written += toWrite;
        <span class="comment">// 更新下buffer的状态</span>
        releaseBuffer(&amp;audioBuffer);
    }

    <span class="keyword">return</span> written;
}
</code></pre><p><code>write</code>函数主要做了：</p>
<ol>
<li>判断这个track是否可以写</li>
<li>对于direct的track，进行一些flag的消除</li>
<li>开始写，主动去获取写的空间，拷贝数据，更新索引，更新buffer状态，检测是否已经还有数据，如果有继续写，没有的话则返回这次写入的数据长度。</li>
</ol>
<p>这个函数里面有两个重要的函数我们要进一步分析的，一个是<code>obtainBuffer</code>，另一个是<code>releaseBuffer</code>.</p>
<p>先来看<code>obtainBuffer</code></p>
<pre><code><span class="keyword">status_t</span> AudioTrack::obtainBuffer(Buffer* audioBuffer, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *requested,
        <span class="keyword">struct</span> timespec *elapsed, <span class="keyword">size_t</span> *nonContig)
{
    <span class="comment">// previous and new IAudioTrack sequence numbers are used to detect track re-creation</span>
    <span class="comment">// 之前和新的sequence用来检测track是否re-creation</span>
    <span class="keyword">uint32_t</span> oldSequence = <span class="number">0</span>;
    <span class="keyword">uint32_t</span> newSequence;

    Proxy::Buffer buffer;
    <span class="keyword">status_t</span> status = NO_ERROR;

    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kMaxTries = <span class="number">5</span>;
    <span class="keyword">int32_t</span> tryCounter = kMaxTries;
    <span class="comment">// 循环的开始</span>
    <span class="keyword">do</span> {
        <span class="comment">// obtainBuffer() is called with mutex unlocked, so keep extra references to these fields to</span>
        <span class="comment">// keep them from going away if another thread re-creates the track during obtainBuffer()</span>
        <span class="comment">// obtainBuffer函数调用必须unlock掉mutex，在此之前有一些参数需要</span>
        sp&lt;AudioTrackClientProxy&gt; proxy;
        sp&lt;IMemory&gt; iMem;

        {   <span class="comment">// start of lock scope</span>
            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;

            newSequence = mSequence;
            <span class="comment">// 是否上一次obtainBuffer失败是由于media server挂掉或者自动放弃治疗？</span>
            <span class="keyword">if</span> (status == DEAD_OBJECT) {
                <span class="comment">// re-create track,除非有人已经做了。</span>
                <span class="keyword">if</span> (newSequence == oldSequence) {
                    <span class="comment">// 会重新createtrack，里面会更新sequence的值</span>
                    status = restoreTrack_l(<span class="string">"obtainBuffer"</span>);
                    <span class="comment">// 一旦restore失败了，则直接跳出来。</span>
                    <span class="keyword">if</span> (status != NO_ERROR) {
                        buffer.mFrameCount = <span class="number">0</span>;
                        buffer.mRaw = <span class="literal">NULL</span>;
                        buffer.mNonContig = <span class="number">0</span>;
                        <span class="keyword">break</span>;
                    }
                }
            }
            <span class="comment">// 更新下sequence</span>
            oldSequence = newSequence;

            <span class="comment">// Keep the extra references</span>
            <span class="comment">// 持有这些额外的引用</span>
            proxy = mProxy;
            iMem = mCblkMemory;
            <span class="comment">// 中途切换成STATE_STOPPING</span>
            <span class="keyword">if</span> (mState == STATE_STOPPING) {
                status = -EINTR;
                buffer.mFrameCount = <span class="number">0</span>;
                buffer.mRaw = <span class="literal">NULL</span>;
                buffer.mNonContig = <span class="number">0</span>;
                <span class="keyword">break</span>;
            }

            <span class="comment">// 如果状态为stoped或者paused的话，将请求设置为non-blocking</span>
            <span class="keyword">if</span> (mState != STATE_ACTIVE) {
                requested = &amp;ClientProxy::kNonBlocking;
            }

        }   <span class="comment">// end of lock scope</span>
        <span class="comment">// 重新组装buffer，传给proxy去获取buffer</span>
        buffer.mFrameCount = audioBuffer-&gt;frameCount;
        <span class="comment">// FIXME starts the requested timeout and elapsed over from scratch</span>
        status = proxy-&gt;obtainBuffer(&amp;buffer, requested, elapsed);
      <span class="comment">// 如果status为DEAD的话，则会等待5次机会，每次都会restore。</span>
    } <span class="keyword">while</span> ((status == DEAD_OBJECT) &amp;&amp; (tryCounter-- &gt; <span class="number">0</span>));
    <span class="comment">// 把获取到的空间数据进行更新到传进来的结构中。</span>
    audioBuffer-&gt;frameCount = buffer.mFrameCount;
    audioBuffer-&gt;size = buffer.mFrameCount * mFrameSize;
    audioBuffer-&gt;raw = buffer.mRaw;
    <span class="keyword">if</span> (nonContig != <span class="literal">NULL</span>) {
        *nonContig = buffer.mNonContig;
    }
    <span class="keyword">return</span> status;
}
</code></pre><p>上面的函数主要实现了：</p>
<ol>
<li>判断IAudioTrack有没有挂掉，如果挂掉的话，进行重新创建</li>
<li>一些对象的引用，不知道目的何在</li>
<li>如果状态切换为STOPPING，则直接退出</li>
<li>如果状态不为ACTIVE，则将请求设置为非阻塞</li>
<li>通过proxy去获取buffer</li>
<li>如果发现track挂掉了，并且次数还没用完则再次循环。</li>
<li>封装数据，返回状态。</li>
</ol>
<p>接下来我们看proxy调用<code>obtainBuffer</code>函数</p>
<pre><code><span class="keyword">status_t</span> ClientProxy::obtainBuffer(Buffer* buffer, <span class="keyword">const</span> <span class="keyword">struct</span> timespec *requested,
        <span class="keyword">struct</span> timespec *elapsed)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>);
    <span class="keyword">struct</span> timespec total;          <span class="comment">// 记录等待所花掉的时间，从当你填满等server消费，通知的时间段</span>
    total.tv_sec = <span class="number">0</span>;
    total.tv_nsec = <span class="number">0</span>;
    <span class="keyword">bool</span> measure = elapsed != <span class="literal">NULL</span>; <span class="comment">// 判断是否需要进行统计时间</span>

    <span class="keyword">status_t</span> status;
    <span class="keyword">enum</span> {
        TIMEOUT_ZERO,       <span class="comment">// requested == NULL || *requested == 0 非阻塞</span>
        TIMEOUT_INFINITE,   <span class="comment">// *requested == infinity 无限等待</span>
        TIMEOUT_FINITE,     <span class="comment">// 0 &lt; *requested &lt; infinity 定时等待</span>
        TIMEOUT_CONTINUE,   <span class="comment">// additional chances after TIMEOUT_FINITE 定时等待的补充</span>
    } timeout;
    <span class="comment">// 默认是阻塞等待，是TIMEOUT_INFINITE</span>
    <span class="keyword">if</span> (requested == <span class="literal">NULL</span>) {
        timeout = TIMEOUT_ZERO;
    } <span class="keyword">else</span> <span class="keyword">if</span> (requested-&gt;tv_sec == <span class="number">0</span> &amp;&amp; requested-&gt;tv_nsec == <span class="number">0</span>) {
        timeout = TIMEOUT_ZERO;
    } <span class="keyword">else</span> <span class="keyword">if</span> (requested-&gt;tv_sec == INT_MAX) {
        timeout = TIMEOUT_INFINITE;
    } <span class="keyword">else</span> {
        timeout = TIMEOUT_FINITE;
        <span class="keyword">if</span> (requested-&gt;tv_sec &gt; <span class="number">0</span> || requested-&gt;tv_nsec &gt;= MEASURE_NS) {
            measure = <span class="literal">true</span>;
        }
    }
    <span class="keyword">struct</span> timespec before;
    <span class="keyword">bool</span> beforeIsValid = <span class="literal">false</span>;
    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
    <span class="keyword">bool</span> ignoreInitialPendingInterrupt = <span class="literal">true</span>;
    <span class="comment">// 检查下share memory是否发生内存脏块，如果有问题，就直接go end</span>
    <span class="keyword">if</span> (mIsShutdown) {
        status = NO_INIT;
        <span class="keyword">goto</span> end;
    }
    <span class="comment">// 无限循环</span>
    <span class="keyword">for</span> (;;) {
        <span class="comment">// 去掉CBLK_INTERRUPT 标志位。并且保存原来的值在flags中</span>
        <span class="keyword">int32_t</span> flags = android_atomic_and(~CBLK_INTERRUPT, &amp;cblk-&gt;mFlags);
        <span class="comment">// 检查server是否将该track认为无效，或者server端挂掉了。</span>
        <span class="keyword">if</span> (flags &amp; CBLK_INVALID) {
            status = DEAD_OBJECT;
            <span class="keyword">goto</span> end;
        }
        <span class="comment">// 检查下obtainBuffer过程是否被client给中断了。第一次不检测，后面都给检测。</span>
        <span class="keyword">if</span> (!ignoreInitialPendingInterrupt &amp;&amp; (flags &amp; CBLK_INTERRUPT)) {
            status = -EINTR;
            <span class="keyword">goto</span> end;
        }
        ignoreInitialPendingInterrupt = <span class="literal">false</span>;
        <span class="comment">// 计算多少帧的空间可以来写，或者多少帧的空间用来读。</span>
        <span class="keyword">int32_t</span> front;
        <span class="keyword">int32_t</span> rear;
        <span class="keyword">if</span> (mIsOut) {
            <span class="comment">// 获取当前填充缓冲区的开头，这个变量是无限递增的</span>
            front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);
            <span class="comment">// 获取当前填充缓冲区的结尾，这个变量是无限递增的。</span>
            rear = cblk-&gt;u.mStreaming.mRear;
        } <span class="keyword">else</span> {
            <span class="comment">// On the other hand, this barrier is required.</span>
            rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);
            front = cblk-&gt;u.mStreaming.mFront;
        }
        <span class="comment">// 计算出当前已经填充的量，就是尚未被消耗的帧。</span>
        <span class="keyword">ssize_t</span> filled = rear - front;
        <span class="comment">// 如果filled的数值不在0到mFrameCount以内，说明内存已经被污染了。</span>
        <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) {
            <span class="keyword">if</span> (mIsOut) {
                <span class="comment">// 设置为shutdown</span>
                mIsShutdown = <span class="literal">true</span>;
                status = NO_INIT;
                <span class="keyword">goto</span> end;
            }
            <span class="comment">// 同步修改下flag添加overrun</span>
            filled = <span class="number">0</span>;
            cblk-&gt;u.mStreaming.mFront = rear;
            (<span class="keyword">void</span>) android_atomic_or(CBLK_OVERRUN, &amp;cblk-&gt;mFlags);
        }
        <span class="comment">// 不允许填充的空间超过管道的大小，如果output的话，则是要填充的，所以是将mFrameCount - </span>
        <span class="comment">// filled， 如果是record，是消费的，所以直接获取filled就行了。</span>
        <span class="keyword">size_t</span> avail = mIsOut ? mFrameCount - filled : filled;
        <span class="comment">// 如果有可写的空间</span>
        <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) {
            <span class="comment">// avail的空间不一定是连续的，可能是后面一节，前面一节，这个时候我们分两次取，先取后面</span>
            <span class="keyword">size_t</span> part1;
            <span class="keyword">if</span> (mIsOut) {
                <span class="comment">// mFrameCountP2这个是mFrameCount的roundup，这边用到了二进制的小技巧，</span>
                <span class="comment">// rear&amp;roundup它的值很好计算。而且真实的空间mFrameCountP2就是这个，只要控制填充量</span>
                <span class="comment">// 不超过mFrameCount就行了。这些变量都是以帧为单位的</span>
                rear &amp;= mFrameCountP2 - <span class="number">1</span>;
                part1 = mFrameCountP2 - rear;
            } <span class="keyword">else</span> {
                front &amp;= mFrameCountP2 - <span class="number">1</span>;
                part1 = mFrameCountP2 - front;
            }
            <span class="comment">// 如果part1 大于avail 那part1只能取到avail，大小我们还是要以mFrameCount的为准的。之</span>
            <span class="comment">// 所以申请mFrameCountP2的空间，完全是为了方便计算。</span>
            <span class="keyword">if</span> (part1 &gt; avail) {
                part1 = avail;
            }
            <span class="comment">// buffer-&gt;mFrameCount这个是用户写过来的数据，如果这个数据比part1还小，那我们只需要分配</span>
            <span class="comment">// 这个空间大小就够了。</span>
            <span class="keyword">if</span> (part1 &gt; buffer-&gt;mFrameCount) {
                part1 = buffer-&gt;mFrameCount;
            }
            <span class="comment">// 重新组装buffer，确定最后分配的空间。</span>
            buffer-&gt;mFrameCount = part1;
            <span class="comment">// 指向的内存空间</span>
            buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?
                    &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? rear : front) * mFrameSize] : <span class="literal">NULL</span>;
            <span class="comment">// 还有多少可用的空间没被使用</span>
            buffer-&gt;mNonContig = avail - part1;
            <span class="comment">// 将申请到的空间大小赋值给mUnreleased，表示尚未被释放，等后面调用release时候，再更新</span>
            mUnreleased = part1;
            status = NO_ERROR;
            <span class="comment">// 如果申请到了空间，那我们就直接跳出这个for循环了。等待write函数中填充好数据在进来获取空</span>
            <span class="comment">// 间。</span>
            <span class="keyword">break</span>;
        }
        <span class="keyword">struct</span> timespec remaining;
        <span class="keyword">const</span> <span class="keyword">struct</span> timespec *ts;
        <span class="keyword">switch</span> (timeout) {
        <span class="keyword">case</span> TIMEOUT_ZERO:
            status = WOULD_BLOCK;
            <span class="keyword">goto</span> end;
        <span class="keyword">case</span> TIMEOUT_INFINITE:
            ts = <span class="literal">NULL</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> TIMEOUT_FINITE:
            <span class="comment">// 被修改成为TIMEOUT_CONTINUE，这边是为了防止平台设置MAX_SEC为0，可以采用自己申请的时间</span>
            <span class="comment">// MAC_SEC表示的是一次所等待的最大时间</span>
            timeout = TIMEOUT_CONTINUE;
            <span class="keyword">if</span> (MAX_SEC == <span class="number">0</span>) {
                ts = requested;
                <span class="keyword">break</span>;
            }
            <span class="comment">// fall through</span>
        <span class="keyword">case</span> TIMEOUT_CONTINUE:
            <span class="comment">// FIXME we do not retry if requested &lt; 10ms? needs documentation on this state machine</span>
            <span class="keyword">if</span> (!measure || requested-&gt;tv_sec &lt; total.tv_sec ||
                    (requested-&gt;tv_sec == total.tv_sec &amp;&amp; requested-&gt;tv_nsec &lt;= total.tv_nsec)) {
                status = TIMED_OUT;
                <span class="keyword">goto</span> end;
            }
            remaining.tv_sec = requested-&gt;tv_sec - total.tv_sec;
            <span class="keyword">if</span> ((remaining.tv_nsec = requested-&gt;tv_nsec - total.tv_nsec) &lt; <span class="number">0</span>) {
                remaining.tv_nsec += <span class="number">1000000000</span>;
                remaining.tv_sec++;
            }
            <span class="comment">// 如果remaining的时间较长，则将强制为MAX_SEC，但是requested的时间并没有减少</span>
            <span class="comment">// 也就是说每次最多等待remaining的长度，知道requested都用光了。</span>
            <span class="keyword">if</span> (<span class="number">0</span> &lt; MAX_SEC &amp;&amp; MAX_SEC &lt; remaining.tv_sec) {
                remaining.tv_sec = MAX_SEC;
                remaining.tv_nsec = <span class="number">0</span>;
            }
            ts = &amp;remaining;
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            LOG_ALWAYS_FATAL(<span class="string">"obtainBuffer() timeout=%d"</span>, timeout);
            ts = <span class="literal">NULL</span>;
            <span class="keyword">break</span>;
        }
        <span class="keyword">int32_t</span> old = android_atomic_and(~CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);
        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) {
            <span class="comment">// 定时阻塞的，这边就会进入去记录阻塞之前的时间点。beforeIsValid一开始默认是false</span>
            <span class="comment">// 的。所以肯定进入了这个变量是保证只需要获取一次开始的，因为之后都是以上一次为准的。而且</span>
            <span class="comment">// 这个超时只针对单次超时，为什么不再进来，因为如果第二次到这说明上次也没获取到，时间</span>
            <span class="comment">// 上一致。</span>
            <span class="keyword">if</span> (measure &amp;&amp; !beforeIsValid) {
                clock_gettime(CLOCK_MONOTONIC, &amp;before);
                beforeIsValid = <span class="literal">true</span>;
            }
            errno = <span class="number">0</span>;
            <span class="comment">// 注意，我们阻塞的时候，是有传入ts这个时间的，这个可以保证时间到了自动继续往下运行</span>
            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,
                    mClientInServer ? FUTEX_WAIT_PRIVATE : FUTEX_WAIT, old &amp; ~CBLK_FUTEX_WAKE, ts);
            <span class="comment">// 阻塞结束之后要计算总共消耗时间。</span>
            <span class="keyword">if</span> (measure) {
                <span class="keyword">struct</span> timespec after;
                clock_gettime(CLOCK_MONOTONIC, &amp;after);
                total.tv_sec += after.tv_sec - before.tv_sec;
                <span class="keyword">long</span> deltaNs = after.tv_nsec - before.tv_nsec;
                <span class="keyword">if</span> (deltaNs &lt; <span class="number">0</span>) {
                    deltaNs += <span class="number">1000000000</span>;
                    total.tv_sec--;
                }
                <span class="keyword">if</span> ((total.tv_nsec += deltaNs) &gt;= <span class="number">1000000000</span>) {
                    total.tv_nsec -= <span class="number">1000000000</span>;
                    total.tv_sec++;
                }
                <span class="comment">// 更新下时间点，和beforeIsValid</span>
                before = after;
                beforeIsValid = <span class="literal">true</span>;
            }
            <span class="comment">// 正常唤醒、出错、超时等都会继续在跑循环。</span>
            <span class="keyword">switch</span> (errno) {
            <span class="keyword">case</span> <span class="number">0</span>:            <span class="comment">// normal wakeup by server, or by binderDied()</span>
            <span class="keyword">case</span> EWOULDBLOCK:  <span class="comment">// benign race condition with server</span>
            <span class="keyword">case</span> EINTR:        <span class="comment">// wait was interrupted by signal or other spurious wakeup</span>
            <span class="keyword">case</span> ETIMEDOUT:    <span class="comment">// time-out expired</span>
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                status = errno;
                ALOGE(<span class="string">"%s unexpected error %s"</span>, __func__, strerror(status));
                <span class="keyword">goto</span> end;
            }
        }
    }

end:
    <span class="keyword">if</span> (status != NO_ERROR) {
        buffer-&gt;mFrameCount = <span class="number">0</span>;
        buffer-&gt;mRaw = <span class="literal">NULL</span>;
        buffer-&gt;mNonContig = <span class="number">0</span>;
        mUnreleased = <span class="number">0</span>;
    }
    <span class="keyword">if</span> (elapsed != <span class="literal">NULL</span>) {
        *elapsed = total;
    }
    <span class="keyword">if</span> (requested == <span class="literal">NULL</span>) {
        requested = &amp;kNonBlocking;
    }
    <span class="keyword">if</span> (measure) {
    }
    <span class="keyword">return</span> status;
}
</code></pre><p>这个函数看起来很长，但是其实它做的事情并不多。</p>
<ol>
<li>获取缓冲区</li>
<li>如果获取不到进入阻塞，看情况需要做个计时的。</li>
</ol>
<p>获取缓冲区，这边采用了小技巧。比如用户空间申请的framecount是666个这个是mFrameCount了，那TrackBase那边会给分配1024个这个就是P2了，rear和front都是无限递增的以帧为单位的int类型，它们是以P2为基准的，就是他们是P2的整数倍，这样我们再获取以填充的空间以及剩余可填充的空间就变得很简单了，直接rear-front就是可以填充的空间，剩余的空间就是mFrameCount-filled就可以得到了。</p>
<p>接着就是考虑如何实现循环缓冲了，其实就是引入part1，这个东西，它会让本来只需要填充一次变成需要填充两次，但是却可以简化编程，让逻辑更简单。如果写入的数据比较多，并且剩余的空间包括后面一小部分和前面一部分，那会先把后面这部分填充完，退出，然后让最外面的去release这个已经使用的部分，再来一次获取空间，这次获取的就是拿到前面这部分的缓冲区了。</p>
<p>接下来我们得来看看<code>releaseBuffer</code>的实现了。</p>
<pre><code><span class="keyword">void</span> AudioTrack::releaseBuffer(<span class="keyword">const</span> Buffer* audioBuffer)
{
    <span class="comment">// mTransfer不能为TRANSFER_SHARED</span>
    <span class="keyword">if</span> (mTransfer == TRANSFER_SHARED) {
        <span class="keyword">return</span>;
    }
    <span class="comment">// 计算这次填充的空间，转换成帧</span>
    <span class="keyword">size_t</span> stepCount = audioBuffer-&gt;size / mFrameSize;
    <span class="keyword">if</span> (stepCount == <span class="number">0</span>) {
        <span class="keyword">return</span>;
    }

    Proxy::Buffer buffer;
    buffer.mFrameCount = stepCount;
    buffer.mRaw = audioBuffer-&gt;raw;

    <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mLock)</span></span>;
    <span class="comment">// release做累加</span>
    mReleased += stepCount;
    mInUnderrun = <span class="literal">false</span>;
    <span class="comment">// 调用proxy的releaseBuffer</span>
    mProxy-&gt;releaseBuffer(&amp;buffer);

    <span class="comment">// 重启track 如果之前被AudioFlinger因为underrun给disable了</span>
    <span class="keyword">if</span> (mState == STATE_ACTIVE) {
        <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
        <span class="keyword">if</span> (android_atomic_and(~CBLK_DISABLED, &amp;cblk-&gt;mFlags) &amp; CBLK_DISABLED) {
            mAudioTrack-&gt;start();
        }
    }
}
</code></pre><p>上面的函数，做个统计，然后就调用proxy的releaseBuffer了。</p>
<pre><code><span class="literal">void</span> ClientProxy<span class="tag">::releaseBuffer</span>(Buffer* buffer)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="built_in">NULL</span>);
    size_t stepCount = buffer<span class="subst">-&gt;</span>mFrameCount;
    <span class="keyword">if</span> (stepCount == <span class="number">0</span> <span class="subst">||</span> mIsShutdown) {
        <span class="comment">// prevent accidental re-use of buffer</span>
        buffer<span class="subst">-&gt;</span>mFrameCount = <span class="number">0</span>;
        buffer<span class="subst">-&gt;</span>mRaw = <span class="built_in">NULL</span>;
        buffer<span class="subst">-&gt;</span>mNonContig = <span class="number">0</span>;
        <span class="keyword">return</span>;
    }
    <span class="comment">// 更新下mUnreleased的值。表示还有多少分配给client的空间未被填充。</span>
    mUnreleased -= stepCount;
    audio_track_cblk_t* cblk = mCblk;
    <span class="comment">// 更新下缓冲区的index。这边可以看出rear和front是一个一直递增的值。</span>
    <span class="keyword">if</span> (mIsOut) {
        int32_t rear = cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mRear;
        android_atomic_release_store(stepCount + rear, <span class="subst">&amp;</span>cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mRear);
    } <span class="keyword">else</span> {
        int32_t front = cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mFront;
        android_atomic_release_store(stepCount + front, <span class="subst">&amp;</span>cblk<span class="subst">-&gt;</span>u<span class="built_in">.</span>mStreaming<span class="built_in">.</span>mFront);
    }
}
</code></pre><h3 id="消费者部分">消费者部分</h3><p>前面我们有提到，消费者是一个线程，这个线程，在我们当前这个场景下是一个普通的mixer thread，其实也是我们前面一直有出现的output thread，这个线程主要就是负责获取数据，mix数据，效果处理等一系列的操作的。每一个普通的mixer thread，它都可能会包含好多个的track，这样的话，它的实现上必然就不能为等待某个track的数据而发生阻塞，只有当所有的track都没数据了，它才会进入休眠状态。<br>当然这边我们讲解的主要场景是获取数据了，获取数据其实是在AudioMixer里面来执行的，但是我们不能只关注获取，我们需要关注的是流程如何控制到获取数据的整个逻辑。所以我们从<code>MixerThread::prepareTracks_l</code>，这边我会先把fast track相关的部分先省略掉，因为我们目前只定位在normal track，其实fast track的逻辑也是差不多的，只是细节实现上更复杂一些。</p>
<pre><code>AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l(
        Vector&lt; sp&lt;Track&gt; &gt; *tracksToRemove)
{

    mixer_state mixerStatus = MIXER_IDLE;
    <span class="comment">// 看有多少个track需要被处理的</span>
    size_t count = mActiveTracks.size();
    size_t mixedTracks = <span class="number">0</span>;
    size_t tracksWithEffect = <span class="number">0</span>;

    <span class="keyword">float</span> masterVolume = mMasterVolume;
    <span class="keyword">bool</span> masterMute = mMasterMute;

    <span class="keyword">if</span> (masterMute) {
        masterVolume = <span class="number">0</span>;
    }
    <span class="comment">// 如果存在全局音效的话，委托全局音效来控制master volume。</span>
    sp&lt;EffectChain&gt; chain = getEffectChain_l(AUDIO_SESSION_OUTPUT_MIX);
    <span class="keyword">if</span> (chain != <span class="number">0</span>) {
        uint32_t v = (uint32_t)(masterVolume * (<span class="number">1</span> &lt;&lt; <span class="number">24</span>));
        chain-&gt;setVolume_l(&amp;v, &amp;v);
        masterVolume = (<span class="keyword">float</span>)((v + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>)) &gt;&gt; <span class="number">24</span>);
        chain.clear();
    }

    mMixerBufferValid = <span class="keyword">false</span>;  <span class="comment">// 有使用mixerbuffer的tracks被找到并且有数据会被置为true</span>
    mEffectBufferValid = <span class="keyword">false</span>; <span class="comment">// 有使用mixerbuffer的tracks被找到并且有数据会被置为true</span>

    <span class="keyword">for</span> (size_t i=<span class="number">0</span> ; i&lt;count ; i++) {
        <span class="keyword">const</span> sp&lt;Track&gt; t = mActiveTracks[i].promote();
        <span class="keyword">if</span> (t == <span class="number">0</span>) {
            <span class="keyword">continue</span>;
        }

        Track* <span class="keyword">const</span> track = t.get();

        {   <span class="comment">// local variable scope to avoid goto warning</span>

        audio_track_cblk_t* cblk = track-&gt;cblk();

        <span class="comment">// 对于第一次被添加进来的track，我们会等待它把buffer都填充满才来处理的。</span>
        <span class="keyword">int</span> name = track-&gt;name();
        <span class="comment">// 为了防止用户在结束的时候没有通过调用stop函数来终止播放，而是依赖underrun来结束，添加了变量</span>
        <span class="comment">// mMixerStatus来记录上一次的track的mix的情况。</span>
        <span class="comment">// mMixerStatus == MIXER_TRACKS_READY意味着上一次的循环，track已经被mixed过了。</span>
        <span class="comment">// 也侧面反映了，上一次还是有数据的，如果上一次没有被mixed过的话，那我们就直接采用最小的来帮忙</span>
        <span class="comment">// 将剩下的数据排空</span>
        size_t desiredFrames;
        <span class="keyword">const</span> uint32_t sampleRate = track-&gt;mAudioTrackServerProxy-&gt;getSampleRate();
        AudioPlaybackRate playbackRate = track-&gt;mAudioTrackServerProxy-&gt;getPlaybackRate();
        <span class="comment">// 确保有足够的数据来填充满hal层的一个buffer</span>
        <span class="comment">// 计算hal层buffer映射到当前速率，采样率下是多少帧</span>
        desiredFrames = sourceFramesNeededWithTimestretch(
                sampleRate, mNormalFrameCount, mSampleRate, playbackRate.mSpeed);
        <span class="comment">// 数据已经被AudioMixer获取，但是尚未release，所以需要加上这个部分，因为此时client还没呈现</span>
        <span class="comment">// 出来变化</span>
        desiredFrames += mAudioMixer-&gt;getUnreleasedFrames(track-&gt;name());

        uint32_t minFrames = <span class="number">1</span>;
        <span class="comment">// minFrames需要AudioMixer在上一轮的操作中已经被enable了，并且track的需要满足下面条件</span>
        <span class="comment">// 才会被设置为desiredFrames，为什么pausing的时候，也不给机会呢，这个时候缓冲区的数据可能</span>
        <span class="comment">// 没办法完全满足desiredFrames，但是我们依然要制造volume ramp，所以只能这么做了。</span>
        <span class="keyword">if</span> ((track-&gt;sharedBuffer() == <span class="number">0</span>) &amp;&amp; !track-&gt;isStopped() &amp;&amp; !track-&gt;isPausing() &amp;&amp;
                (mMixerStatusIgnoringFastTracks == MIXER_TRACKS_READY)) {
            minFrames = desiredFrames;
        }

        size_t framesReady = track-&gt;framesReady();
        <span class="comment">// 对于pause的场景，是会直接戛然而止，而不会将app写进去尚未消费的数据用掉</span>
        <span class="comment">// 对于stop的场景， 是会将数据都用光的。</span>
        <span class="keyword">if</span> ((framesReady &gt;= minFrames) &amp;&amp; track-&gt;isReady() &amp;&amp;
                !track-&gt;isPaused() &amp;&amp; !track-&gt;isTerminated())
        {
            mixedTracks++;

            chain.clear();
            <span class="keyword">if</span> (track-&gt;mainBuffer() != mSinkBuffer &amp;&amp;
                    track-&gt;mainBuffer() != mMixerBuffer) {
                <span class="keyword">if</span> (mEffectBufferEnabled) {
                    mEffectBufferValid = <span class="keyword">true</span>; <span class="comment">// Later can set directly.</span>
                }
                <span class="comment">// 能进入到这边，说明这个track关联到了一个效果链中。</span>
                chain = getEffectChain_l(track-&gt;sessionId());
                <span class="keyword">if</span> (chain != <span class="number">0</span>) {
                    tracksWithEffect++;
                } <span class="keyword">else</span> {
                }
            }

            <span class="keyword">int</span> param = AudioMixer::VOLUME;
            <span class="keyword">if</span> (track-&gt;mFillingUpStatus == Track::FS_FILLED) {
                <span class="comment">// no ramp for the first volume setting</span>
                <span class="comment">// 对于第一次的音量设置，不采用ramp volume，一旦进来就被设置为FS_ACTIVE了。</span>
                track-&gt;mFillingUpStatus = Track::FS_ACTIVE;
                <span class="comment">// RESUMING只有pausing或者PAUSED才可能触发,比如paused过程中，出现mediaserver挂掉</span>
                <span class="keyword">if</span> (track-&gt;mState == TrackBase::RESUMING) {
                    track-&gt;mState = TrackBase::ACTIVE;
                    param = AudioMixer::RAP_MVOLUME;
                }
                mAudioMixer-&gt;setParameter(name, AudioMixer::RESAMPLE, AudioMixer::RESET, <span class="keyword">NULL</span>);
            } <span class="keyword">else</span> <span class="keyword">if</span> (cblk-&gt;mServer != <span class="number">0</span>) {
                param = AudioMixer::RAMP_VOLUME;
            }

            <span class="comment">// compute volume for this track</span>
            uint32_t vl, vr;       <span class="comment">// in U8.24 integer format</span>
            <span class="keyword">float</span> vlf, vrf, vaf;   <span class="comment">// in [0.0, 1.0] float format</span>
            <span class="comment">// 对于pause的场景或者静音，添加一个volume ramp的效果，也增加出pausing的状态。</span>
            <span class="keyword">if</span> (track-&gt;isPausing() || mStreamTypes[track-&gt;streamType()].mute) {
                vl = vr = <span class="number">0</span>;
                vlf = vrf = vaf = <span class="number">0.</span>;
                <span class="keyword">if</span> (track-&gt;isPausing()) {
                    track-&gt;setPaused();
                }
            } <span class="keyword">else</span> {

                <span class="comment">// read original volumes with volume control</span>
                <span class="keyword">float</span> typeVolume = mStreamTypes[track-&gt;streamType()].volume;
                <span class="keyword">float</span> v = masterVolume * typeVolume;
                AudioTrackServerProxy *proxy = track-&gt;mAudioTrackServerProxy;
                gain_minifloat_packed_t vlr = proxy-&gt;getVolumeLR();
                vlf = float_from_gain(gain_minifloat_unpack_left(vlr));
                vrf = float_from_gain(gain_minifloat_unpack_right(vlr));
                <span class="comment">// track volumes come from shared memory, so can't be trusted and must be clamped</span>
                <span class="keyword">if</span> (vlf &gt; GAIN_FLOAT_UNITY) {
                    vlf = GAIN_FLOAT_UNITY;
                }
                <span class="keyword">if</span> (vrf &gt; GAIN_FLOAT_UNITY) {
                    vrf = GAIN_FLOAT_UNITY;
                }
                <span class="comment">// now apply the master volume and stream type volume</span>
                vlf *= v;
                vrf *= v;
                <span class="comment">// assuming master volume and stream type volume each go up to 1.0,</span>
                <span class="comment">// then derive vl and vr as U8.24 versions for the effect chain</span>
                <span class="keyword">const</span> <span class="keyword">float</span> scaleto8_24 = MAX_GAIN_INT * MAX_GAIN_INT;
                vl = (uint32_t) (scaleto8_24 * vlf);
                vr = (uint32_t) (scaleto8_24 * vrf);
                <span class="comment">// vl and vr are now in U8.24 format</span>
                uint16_t sendLevel = proxy-&gt;getSendLevel_U4_12();
                <span class="comment">// send level comes from shared memory and so may be corrupt</span>
                <span class="keyword">if</span> (sendLevel &gt; MAX_GAIN_INT) {
                    sendLevel = MAX_GAIN_INT;
                }
                <span class="comment">// vaf is represented as [0.0, 1.0] float by rescaling sendLevel</span>
                vaf = v * sendLevel * (<span class="number">1.</span> / MAX_GAIN_INT);
            }

            <span class="comment">// 将音量控制委托给效果链</span>
            <span class="keyword">if</span> (chain != <span class="number">0</span> &amp;&amp; chain-&gt;setVolume_l(&amp;vl, &amp;vr)) {
                <span class="comment">// 如果效果链掌控音量控制，则不要使用ramp volume</span>
                param = AudioMixer::VOLUME;
                <span class="comment">// 更新下音量值</span>
                vlf = (<span class="keyword">float</span>)vl / (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);
                vrf = (<span class="keyword">float</span>)vr / (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);
                track-&gt;mHasVolumeController = <span class="keyword">true</span>;
            } <span class="keyword">else</span> {
                <span class="comment">// force no volume ramp when volume controller was just disabled or removed</span>
                <span class="comment">// from effect chain to avoid volume spike</span>
                <span class="keyword">if</span> (track-&gt;mHasVolumeController) {
                    param = AudioMixer::VOLUME;
                }
                track-&gt;mHasVolumeController = <span class="keyword">false</span>;
            }

            <span class="comment">// <span class="doctag">XXX:</span> these things DON'T need to be done each time</span>
            mAudioMixer-&gt;setBufferProvider(name, track);
            mAudioMixer-&gt;enable(name);

            mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME0, &amp;vlf);
            mAudioMixer-&gt;setParameter(name, param, AudioMixer::VOLUME1, &amp;vrf);
            mAudioMixer-&gt;setParameter(name, param, AudioMixer::AUXLEVEL, &amp;vaf);
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::FORMAT, (void *)track-&gt;format());
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::CHANNEL_MASK, (void *)(uintptr_t)track-&gt;channelMask());
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::MIXER_CHANNEL_MASK, (void *)(uintptr_t)mChannelMask);
            <span class="comment">// limit track sample rate to 2 x output sample rate, which changes at re-configuration</span>
            uint32_t maxSampleRate = mSampleRate * AUDIO_RESAMPLER_DOWN_RATIO_MAX;
            uint32_t reqSampleRate = track-&gt;mAudioTrackServerProxy-&gt;getSampleRate();
            <span class="keyword">if</span> (reqSampleRate == <span class="number">0</span>) {
                reqSampleRate = mSampleRate;
            } <span class="keyword">else</span> <span class="keyword">if</span> (reqSampleRate &gt; maxSampleRate) {
                reqSampleRate = maxSampleRate;
            }
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::RESAMPLE,
                AudioMixer::SAMPLE_RATE,
                (void *)(uintptr_t)reqSampleRate);

            AudioPlaybackRate playbackRate = track-&gt;mAudioTrackServerProxy-&gt;getPlaybackRate();
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TIMESTRETCH,
                AudioMixer::PLAYBACK_RATE,
                &amp;playbackRate);

            <span class="comment">// 如果mMixerBufferEnabled并且当前这个track的输出buffer是sinkbuffer或者</span>
            <span class="comment">// mixerbuffer，则设置输出buffer为mixerbuffer，否则的话都设置为track之前设置的</span>
            <span class="comment">// buffer。</span>
            <span class="keyword">if</span> (mMixerBufferEnabled
                    &amp;&amp; (track-&gt;mainBuffer() == mSinkBuffer
                            || track-&gt;mainBuffer() == mMixerBuffer)) {
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MIXER_FORMAT, (void *)mMixerBufferFormat);
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MAIN_BUFFER, (void *)mMixerBuffer);
                mMixerBufferValid = <span class="keyword">true</span>;
            } <span class="keyword">else</span> {
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MIXER_FORMAT, (void *)AUDIO_FORMAT_PCM_16_BIT);
                mAudioMixer-&gt;setParameter(
                        name,
                        AudioMixer::TRACK,
                        AudioMixer::MAIN_BUFFER, (void *)track-&gt;mainBuffer());
            }
            mAudioMixer-&gt;setParameter(
                name,
                AudioMixer::TRACK,
                AudioMixer::AUX_BUFFER, (void *)track-&gt;auxBuffer());

            <span class="comment">// reset retry count</span>
            track-&gt;mRetryCount = kMaxTrackRetries;

            <span class="comment">// 如果上一次没有ready，这次只要有一个track已经ready，则为ready</span>
            <span class="keyword">if</span> (mMixerStatusIgnoringFastTracks != MIXER_TRACKS_READY ||
                    mixerStatus != MIXER_TRACKS_ENABLED) {
                mixerStatus = MIXER_TRACKS_READY;
            }
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (framesReady &lt; desiredFrames &amp;&amp; !track-&gt;isStopped() &amp;&amp; !track-&gt;isPaused()) {
                track-&gt;mAudioTrackServerProxy-&gt;tallyUnderrunFrames(desiredFrames);
            }
            <span class="comment">// clear effect chain input buffer if an active track underruns to avoid sending</span>
            <span class="comment">// previous audio buffer again to effects</span>
            chain = getEffectChain_l(track-&gt;sessionId());
            <span class="keyword">if</span> (chain != <span class="number">0</span>) {
                chain-&gt;clearInputBuffer();
            }
            <span class="comment">// 如果track是使用共享内存，或者已经终止、停止、暂停，则会进入下面逻辑。 </span>
            <span class="keyword">if</span> ((track-&gt;sharedBuffer() != <span class="number">0</span>) || track-&gt;isTerminated() ||
                    track-&gt;isStopped() || track-&gt;isPaused()) {
                <span class="comment">// 会在继续填充latency的时间长度的空白数据，这个有优化空间</span>
                size_t audioHALFrames = (latency_l() * mSampleRate) / <span class="number">1000</span>;
                size_t framesWritten = mBytesWritten / mFrameSize;
                <span class="keyword">if</span> (mStandby || track-&gt;presentationComplete(framesWritten, audioHALFrames)) {
                    <span class="comment">// 如果track是stopped状态，则重置track。</span>
                    <span class="keyword">if</span> (track-&gt;isStopped()) {
                        track-&gt;reset();
                    }
                    <span class="comment">// 加入到移除队列</span>
                    tracksToRemove-&gt;add(track);
                }
            } <span class="keyword">else</span> {
                <span class="comment">// 如果不是共享内存，并且当前状态不是终止、停止、暂停，就说明肯定就是数据给的不够。</span>
                <span class="comment">// 这个时候会给它50次的机会进行填充，如果还不满足就移掉active list了。</span>
                <span class="keyword">if</span> (--(track-&gt;mRetryCount) &lt;= <span class="number">0</span>) {
                    tracksToRemove-&gt;add(track);
                    <span class="comment">// 告诉app的track由于underrun被disable，如果数据够，会自动调用start()方法</span>
                    android_atomic_or(CBLK_DISABLED, &amp;cblk-&gt;mFlags);
                <span class="comment">// 只要有一个active track尚未ready，那就标志mixer states为not ready</span>
                <span class="comment">// 但是这边有个例外的，上一次已经设置为enable，并且有两个track，一个ready，另外</span>
                <span class="comment">// 一个not ready，则这次的mixer states会被设置为READY</span>
                } <span class="keyword">else</span> <span class="keyword">if</span> (mMixerStatusIgnoringFastTracks == MIXER_TRACKS_READY ||
                                mixerStatus != MIXER_TRACKS_READY) {
                    mixerStatus = MIXER_TRACKS_ENABLED;
                }
            }
            <span class="comment">// 这边会将AudioMixer disable。</span>
            mAudioMixer-&gt;disable(name);
        }

        }   <span class="comment">// local variable scope to avoid goto warning</span>
track_is_ready: ;

    }

    <span class="comment">// Push the new FastMixer state if necessary</span>
    <span class="keyword">bool</span> pauseAudioWatchdog = <span class="keyword">false</span>;
<span class="comment">#ifdef AUDIO_WATCHDOG</span>
    <span class="keyword">if</span> (pauseAudioWatchdog &amp;&amp; mAudioWatchdog != <span class="number">0</span>) {
        mAudioWatchdog-&gt;pause();
    }
<span class="comment">#endif</span>

    <span class="comment">// remove all the tracks that need to be...</span>
    removeTracks_l(*tracksToRemove);
    <span class="comment">// 如果有全局效果链的话，则设置状态位。</span>
    <span class="keyword">if</span> (getEffectChain_l(AUDIO_SESSION_OUTPUT_MIX) != <span class="number">0</span>) {
        mEffectBufferValid = <span class="keyword">true</span>;
    }

    <span class="keyword">if</span> (mEffectBufferValid) {
        <span class="comment">// 有效果的话，我们需要把effect buffer清空，避免有不干净的数据进入到效果链中</span>
        memset(mEffectBuffer, <span class="number">0</span>, mEffectBufferSize);
    }
    <span class="comment">// 如果所有的track都链接到一个效果链，这种情况下audiomixer将不会写数据到sink或者mixbuffer，</span>
    <span class="comment">// 并且track的效果将会添加进来，所以我们需要清空sink和mix的buffer。</span>
    <span class="keyword">if</span> ((mBytesRemaining == <span class="number">0</span>) &amp;&amp; ((mixedTracks != <span class="number">0</span>) &amp;&amp; (mixedTracks == tracksWithEffect) || (mixedTracks == <span class="number">0</span> &amp;&amp; fastTracks &gt; <span class="number">0</span>))) {
        <span class="keyword">if</span> (mMixerBufferValid) {
            memset(mMixerBuffer, <span class="number">0</span>, mMixerBufferSize);
            <span class="comment">// mSinkBuffer最后会从MixerBuffer中拷贝数据到SinkBuffer，所以不需要清空</span>
        }
        memset(mSinkBuffer, <span class="number">0</span>, mNormalFrameCount * mFrameSize);
    }

    <span class="comment">// mMixerStatusIgnoringFastTracks这个是用来对付normal track的，而之前mMixerStatus用来对付全</span>
    <span class="comment">// 局的</span>
    mMixerStatusIgnoringFastTracks = mixerStatus;
    <span class="keyword">if</span> (fastTracks &gt; <span class="number">0</span>) {
        mixerStatus = MIXER_TRACKS_READY;
    }
    <span class="keyword">return</span> mixerStatus;
}
</code></pre><p>这个函数其实蛮复杂的，因为它不仅关注了这个thread中的所有track的状态，还需要对缓冲区进行清理等工作。</p>
<p>我们来一起总结下，先看下只有一个track的情况：</p>
<ol>
<li>如果该track被添加到active list，那这边就可以检索到了，fast的先略过，那这个函数会去当前的track的状态，以及是否上次循环已经有mixed过了，来决定它的填充帧数的要求；</li>
<li>判断是否ready了，第一次的填充需要将app申请缓冲区都填满，之后就会将mFillingUpStatus设置为filled，那之后这边就直接pass了</li>
<li>判断暂停、停止、终止等状态</li>
<li>如果以上都pass的话，那就会开始进行audiomixer的设置，包括音量，缓冲区，格式等一系列可能需要在mixer中完成的参数告诉它，因为可能牵扯到downmix、reformat、resampler等等。并且使能audiomixer</li>
<li>更新下mMixerStatus和mMixerStatusIgnoringFastTracks</li>
<li>如果有效果的话，则对缓冲区进行相关清理等工作。</li>
</ol>
<p>一个track，但是只有play，没有write操作：</p>
<ol>
<li>判断是否ready的时候肯定就fail了，所以进入到else的分支中。</li>
<li>此时的帧数肯定不满足要求的，并且状态不是停止或暂停，所以会告诉client你已经underrun了</li>
<li>获取效果链，清除输入buffer，开始计数underrun的次数，如果达到50次，将移除该track</li>
<li>没有达到的话，则更新下mMixerStatus和mMixerStatusIgnoringFastTracks</li>
<li>disable audiomixer</li>
<li>将track移除操作</li>
</ol>
<p>一个track，paly、write、之后stop，直接从stop开始分析：</p>
<ol>
<li>接收到stop之后，minFrames就只会等于1了</li>
<li>然后会进入enable audiomixer的流程中，将client端写入的数据全部用完</li>
<li>用完之后，在进入的时候就没办法pass enable的流程，这个时候就会进入到else分支中</li>
<li>发现是stop的情况，会进行latency时间长度的填充空白数据的流程</li>
<li>等填充满latency时间长度之后，就将该track remove掉，会reset该track</li>
</ol>
<p>一个track，play、write、之后pause，直接从pause开始：</p>
<ol>
<li>接收到pause之后，会先进入pausing的过程，这个时候minFrames也是为1的</li>
<li>然后会进入到enable audiomixer的流程中，这个时候会将pausing转变为paused的状态，并且音量设置为0，实现volume ramp的效果</li>
<li>下一次就无法进入enable audiomixer的流程，进入到else分支中</li>
<li>发现是paused的情况，会进行latency时间长度的填充空白数据的流程</li>
<li>等填充慢lantecy时间长度之后，就将该track remove掉，不会有reset track的流程</li>
</ol>
<p>2个track，一个play，write，一个只play，不write：<br>这种情况只是想要分析下mMixerStatus和mMixerStatusIgnoringFastTracks的状态，因为这个状态的更新都有对上一次的循环的mMixerStatusIgnoringFastTracks做判断的。所以它是具有独特性的，这种状态下面mMixerStatusIgnoringFastTracks的状态变化是，ready和enable交替出现的。</p>
<p>enable的话是不会触发audiomixer的执行流程的，只有ready才会触发该audiomixer的执行。如下面代码</p>
<pre><code><span class="keyword">if</span> (mMixerStatus == MIXER_TRACKS_READY) {
    <span class="comment">// threadLoop_mix() sets mCurrentWriteLength</span>
    threadLoop_mix();
} <span class="keyword">else</span> <span class="keyword">if</span> ((mMixerStatus != MIXER_DRAIN_TRACK)
            &amp;&amp; (mMixerStatus != MIXER_DRAIN_ALL)) {
    <span class="comment">// mSleepTimeUs如果为0表示有数据要马上写到底层，就是触发threadloop_write的逻辑，否则sleep</span>
    threadLoop_sleepTime();
    <span class="keyword">if</span> (mSleepTimeUs == <span class="number">0</span>) {
        mCurrentWriteLength = mSinkBufferSize;
    }
}
</code></pre><p>一次ready一次enable的话，那就是mix一次之后要sleep一次，再mix一次，再sleep一次，第一次是mix的，所以sleeptime在mix的函数中被设置为0了。第二次是enable。</p>
<pre><code><span class="keyword">void</span> AudioFlinger::MixerThread::threadLoop_sleepTime()
{
    <span class="keyword">if</span> (mSleepTimeUs == <span class="number">0</span>) {
        <span class="keyword">if</span> (mMixerStatus == MIXER_TRACKS_ENABLED) {
            <span class="comment">// 将时间进行缩减， mActiveSleepTimeUs时间相当于hal buffer排空所需要的时间</span>
            mSleepTimeUs = mActiveSleepTimeUs &gt;&gt; sleepTimeShift;
            <span class="comment">// 有个最小的阈值</span>
            <span class="keyword">if</span> (mSleepTimeUs &lt; kMinThreadSleepTimeUs) {
                mSleepTimeUs = kMinThreadSleepTimeUs;
            }
            <span class="comment">// 我们再不停的缩减sleeptime的时间，就是为了防止app underruns个没玩，导致hal层无法播放</span>
            <span class="comment">// 断续问题。不能因为其中一个underrun导致，另外一个track的数据供应也出问题，所以时间上</span>
            <span class="comment">// 是非常讲究的</span>
            <span class="keyword">if</span> (sleepTimeShift &lt; kMaxThreadSleepTimeShift) {
                sleepTimeShift++;
            }
        } <span class="keyword">else</span> {
            mSleepTimeUs = mIdleSleepTimeUs;
        }
    } <span class="keyword">else</span> <span class="keyword">if</span> (mBytesWritten != <span class="number">0</span> || (mMixerStatus == MIXER_TRACKS_ENABLED)) {
        <span class="comment">// 需要已经连续两次的mix status不为ready才会进来到这了。基本上表示没有数据了。</span>
        <span class="comment">// 在效果执行之前，我们根据情况清空对应的buffer</span>
        <span class="keyword">if</span> (mMixerBufferValid) {
            <span class="built_in">memset</span>(mMixerBuffer, <span class="number">0</span>, mMixerBufferSize);
        } <span class="keyword">else</span> {
            <span class="built_in">memset</span>(mSinkBuffer, <span class="number">0</span>, mSinkBufferSize);
        }
        <span class="comment">// 然后将时间又设置为0</span>
        mSleepTimeUs = <span class="number">0</span>;
    }
}
</code></pre><p>上面函数的逻辑就是怎么计算sleeptime了。一旦出现mixer status状态不为ready我们就需要考虑睡多久的问题，这样将本来需要process的时间跟pass掉，可以起到降低功耗的作用。但是对于那个有write的track来说，本来是一直getbuffer-&gt;mix-&gt;write，现在则是getbuffer-&gt;mix-&gt;write-&gt;sleep-&gt;getbuffer-&gt;mix-&gt;write，而sleep的时间长度虽然是递减的，基本上变成了往底层写一个buffer的大小的数据，然后再等待数据播放完成之后，再写一个buffer的数据。</p>
<p>sleeptime相关write逻辑：</p>
<pre><code><span class="comment">// 如果mSleepTimeUs为0并且有mix、effect了一些数据，那就执行写操作，更新下写的数量和剩余的数量</span>
<span class="keyword">if</span> (mSleepTimeUs == <span class="number">0</span>) {
    <span class="keyword">ssize_t</span> ret = <span class="number">0</span>;
    <span class="keyword">if</span> (mBytesRemaining) {
        ret = threadLoop_write();
        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {
            mBytesRemaining = <span class="number">0</span>;
        } <span class="keyword">else</span> {
            mBytesWritten += ret;
            mBytesRemaining -= ret;
        }
    <span class="comment">// 如果当前mixer的状态为MIXER_DRAIN_TRACK和MIXER_DRAIN_ALL，则进行drain的操作</span>
    } <span class="keyword">else</span> <span class="keyword">if</span> ((mMixerStatus == MIXER_DRAIN_TRACK) ||
            (mMixerStatus == MIXER_DRAIN_ALL)) {
        threadLoop_drain();
    }
    <span class="comment">// 这是针对mixer线程的</span>
    <span class="keyword">if</span> (mType == MIXER &amp;&amp; !mStandby) {
        <span class="comment">// write blocked detection</span>
        <span class="keyword">nsecs_t</span> now = systemTime();
        <span class="comment">// 写数据阻塞用掉的时间</span>
        <span class="keyword">nsecs_t</span> delta = now - mLastWriteTime;
        <span class="comment">// 阻塞时间太长的话，进行一些统计等。</span>
        <span class="keyword">if</span> (delta &gt; maxPeriod) {
            mNumDelayedWrites++;
            <span class="keyword">if</span> ((now - lastWarning) &gt; kWarningThrottleNs) {
                lastWarning = now;
            }
        }
        <span class="comment">// mThreadThrottle默认开启，并且写入一些数据了</span>
        <span class="keyword">if</span> (mThreadThrottle
                &amp;&amp; mMixerStatus == MIXER_TRACKS_READY <span class="comment">// we are mixing (active tracks)</span>
                &amp;&amp; ret &gt; <span class="number">0</span>) {                         <span class="comment">// we wrote something</span>
            <span class="comment">// 这边是用来限制这个loop跑得太快的。要求是小于2倍的预期的，也就是halfbuffer的长度</span>
            <span class="comment">// 同时也有助于app那边填充数据。如果这个线程跑太快，app线程慢了的话，就会出现underrun了</span>
            <span class="comment">// 当然是针对小buffer的场景</span>

            <span class="keyword">const</span> <span class="keyword">int32_t</span> deltaMs = delta / <span class="number">1000000</span>;
            <span class="comment">// throttleMs这个大于0的话，说明底层数据所剩得不是很多，上层数据给的比较慢，所以我们要</span>
            <span class="comment">// 等等上层。如果小于0的话，则说明底层数据有点应付不过来了，那我们就不需要等待了。</span>
            <span class="keyword">const</span> <span class="keyword">int32_t</span> throttleMs = mHalfBufferMs - deltaMs;
            <span class="comment">// 如果halfbuffer的时间大于等于throttleMs，并且throttleMs大于0，则进行sleep来耗时间</span>
            <span class="keyword">if</span> ((<span class="keyword">signed</span>)mHalfBufferMs &gt;= throttleMs &amp;&amp; throttleMs &gt; <span class="number">0</span>) {
                usleep(throttleMs * <span class="number">1000</span>);
                mThreadThrottleTimeMs += throttleMs;
            } <span class="keyword">else</span> {
                <span class="comment">// 这边的代码则是完全为了方便debug。</span>
                <span class="keyword">uint32_t</span> diff = mThreadThrottleTimeMs - mThreadThrottleEndMs;
                <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) {
                    mThreadThrottleEndMs = mThreadThrottleTimeMs;
                }
            }
        }
    }

} <span class="keyword">else</span> {
    ATRACE_BEGIN(<span class="string">"sleep"</span>);
    usleep(mSleepTimeUs);
    ATRACE_END();
}
</code></pre><p>我们之前只是看到<code>prepareTracks_l</code>那边有去判断是否数据准备好了，有去enable audiomixer，那获取数据，消费数据的又是在哪里做的呢？</p>
<p>其实就在我们audiomixer里面，是通过<code>threadloop_mix</code>进去的。我们直接拿audiomixer里面的代码来看就好了：</p>
<pre><code>void AudioMixer::process_NoResampleOneTrack(state_t* state, int64_t pts)
{
    <span class="comment">// 返回左起第一个‘1’之前0的个数。i表示的是右边算起来第几位</span>
    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">31</span> - __builtin_clz(state-&gt;enabledTracks);
    track_t *t = &amp;state-&gt;tracks[i];
    <span class="keyword">const</span> uint32_t channels = t-&gt;mMixerChannelCount;
    <span class="comment">// 获取输出的buffer</span>
    TO* out = reinterpret_cast&lt;TO*&gt;(t-&gt;mainBuffer);
    TA* aux = reinterpret_cast&lt;TA*&gt;(t-&gt;auxBuffer);
    <span class="keyword">const</span> <span class="keyword">bool</span> ramp = t-&gt;needsRamp();
    <span class="comment">// state-&gt;frameCount这个值是创建audiomixer的时候给的。为NormalFrameCount，非fast的话，就是</span>
    <span class="comment">// hal层的buffer大小了</span>
    <span class="keyword">for</span> (size_t numFrames = state-&gt;frameCount; numFrames; ) {
        <span class="comment">// 获取该track的buffer对象</span>
        AudioBufferProvider::Buffer&amp; b(t-&gt;buffer);
        <span class="comment">// 组装buffer信息</span>
        b.frameCount = numFrames;
        <span class="keyword">const</span> int64_t outputPTS = calculateOutputPTS(*t, pts, state-&gt;frameCount - numFrames);
        <span class="comment">// 触发track getNextBuffer被调用，该函数也只是简单的封装对象给serverproxy的obtainBuffer</span>
        <span class="comment">// 然后将输出结果进行封装，返回回来。</span>
        t-&gt;bufferProvider-&gt;getNextBuffer(&amp;b, outputPTS);
        <span class="comment">// 获取到的数据的指针位置</span>
        <span class="keyword">const</span> TI *in = reinterpret_cast&lt;TI*&gt;(b.raw);
.
        <span class="comment">// track被flush或者没有数据，为什么&amp;3，因为采样精度是8的倍数</span>
        <span class="keyword">if</span> (in == <span class="keyword">NULL</span> || (((uintptr_t)in) &amp; <span class="number">3</span>)) {
            memset(out, <span class="number">0</span>, numFrames
                    * channels * audio_bytes_per_sample(t-&gt;mMixerFormat));
            <span class="keyword">return</span>;
        }
        <span class="comment">// 获取到的具体的数据量</span>
        <span class="keyword">const</span> size_t outFrames = b.frameCount;
        <span class="comment">// 给弄上声音，拷贝到out中</span>
        volumeMix&lt;MIXTYPE, is_same&lt;TI, <span class="keyword">float</span>&gt;::value, <span class="keyword">false</span>&gt; (
                out, outFrames, in, aux, ramp, t);
        <span class="comment">// out索引更新</span>
        out += outFrames * channels;
        <span class="keyword">if</span> (aux != <span class="keyword">NULL</span>) {
            aux += channels;
        }
        numFrames -= b.frameCount;

        <span class="comment">// release buffer</span>
        t-&gt;bufferProvider-&gt;releaseBuffer(&amp;b);
    }
    <span class="keyword">if</span> (ramp) {
        t-&gt;adjustVolumeRamp(aux != <span class="keyword">NULL</span>, is_same&lt;TI, <span class="keyword">float</span>&gt;::value);
    }
}
</code></pre><p>该函数是audiomixer对于一个track并且不需要resampler的处理，其他的resampler或者多个track的会复杂一些，但是获取数据、消费数据是一致的。resampler和多个track等audiomixer的场景，我们后面再来分析重要的函数，看是如何处理buffer这个问题的。</p>
<p>接下来我们直接来看serverproxy中的<code>obtainBuffer</code>和<code>releaseBuffer</code></p>
<pre><code><span class="keyword">status_t</span> ServerProxy::obtainBuffer(Buffer* buffer, <span class="keyword">bool</span> ackFlush)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span> || buffer-&gt;mFrameCount == <span class="number">0</span>);
    <span class="keyword">if</span> (mIsShutdown) {
        <span class="keyword">goto</span> no_init;
    }
    {
    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
    <span class="keyword">int32_t</span> front;
    <span class="keyword">int32_t</span> rear;
    <span class="keyword">if</span> (mIsOut) {
        <span class="comment">// 相对于client的实现，多出了flush的部分。其他的算法思路都跟client是一样的。</span>
        <span class="keyword">int32_t</span> flush = cblk-&gt;u.mStreaming.mFlush;
        rear = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mRear);
        front = cblk-&gt;u.mStreaming.mFront;
        <span class="keyword">if</span> (flush != mFlush) {
            <span class="comment">// effectively obtain then release whatever is in the buffer</span>
            <span class="keyword">const</span> <span class="keyword">size_t</span> overflowBit = mFrameCountP2 &lt;&lt; <span class="number">1</span>;
            <span class="keyword">const</span> <span class="keyword">size_t</span> mask = overflowBit - <span class="number">1</span>;
            <span class="keyword">int32_t</span> newFront = (front &amp; ~mask) | (flush &amp; mask);
            <span class="keyword">ssize_t</span> filled = rear - newFront;
            <span class="keyword">if</span> (filled &gt;= (<span class="keyword">ssize_t</span>)overflowBit) {
                <span class="comment">// front and rear offsets span the overflow bit of the p2 mask</span>
                <span class="comment">// so rebasing newFront on the front offset is off by the overflow bit.</span>
                <span class="comment">// adjust newFront to match rear offset.</span>
                ALOGV(<span class="string">"flush wrap: filled %zx &gt;= overflowBit %zx"</span>, filled, overflowBit);
                newFront += overflowBit;
                filled -= overflowBit;
            }
            <span class="comment">// Rather than shutting down on a corrupt flush, just treat it as a full flush</span>
            <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) {
                newFront = rear;
            }
            mFlush = flush;
            android_atomic_release_store(newFront, &amp;cblk-&gt;u.mStreaming.mFront);
            <span class="comment">// There is no danger from a false positive, so err on the side of caution</span>
            <span class="keyword">if</span> (<span class="literal">true</span> <span class="comment">/*front != newFront*/</span>) {
                <span class="keyword">int32_t</span> old = android_atomic_or(CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);
                <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) {
                    (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,
                            mClientInServer ? FUTEX_WAKE_PRIVATE : FUTEX_WAKE, <span class="number">1</span>);
                }
            }
            front = newFront;
        }
    } <span class="keyword">else</span> {
        front = android_atomic_acquire_load(&amp;cblk-&gt;u.mStreaming.mFront);
        rear = cblk-&gt;u.mStreaming.mRear;
    }
    <span class="keyword">ssize_t</span> filled = rear - front;
    <span class="comment">// pipe should not already be overfull</span>
    <span class="keyword">if</span> (!(<span class="number">0</span> &lt;= filled &amp;&amp; (<span class="keyword">size_t</span>) filled &lt;= mFrameCount)) {
        mIsShutdown = <span class="literal">true</span>;
    }
    <span class="keyword">if</span> (mIsShutdown) {
        <span class="keyword">goto</span> no_init;
    }
    <span class="comment">// don't allow filling pipe beyond the nominal size</span>
    <span class="keyword">size_t</span> availToServer;
    <span class="keyword">if</span> (mIsOut) {
        availToServer = filled;
        mAvailToClient = mFrameCount - filled;
    } <span class="keyword">else</span> {
        availToServer = mFrameCount - filled;
        mAvailToClient = filled;
    }
    <span class="comment">// 'availToServer' may be non-contiguous, so return only the first contiguous chunk</span>
    <span class="keyword">size_t</span> part1;
    <span class="keyword">if</span> (mIsOut) {
        front &amp;= mFrameCountP2 - <span class="number">1</span>;
        part1 = mFrameCountP2 - front;
    } <span class="keyword">else</span> {
        rear &amp;= mFrameCountP2 - <span class="number">1</span>;
        part1 = mFrameCountP2 - rear;
    }
    <span class="keyword">if</span> (part1 &gt; availToServer) {
        part1 = availToServer;
    }
    <span class="keyword">size_t</span> ask = buffer-&gt;mFrameCount;
    <span class="keyword">if</span> (part1 &gt; ask) {
        part1 = ask;
    }
    <span class="comment">// is assignment redundant in some cases?</span>
    buffer-&gt;mFrameCount = part1;
    buffer-&gt;mRaw = part1 &gt; <span class="number">0</span> ?
            &amp;((<span class="keyword">char</span> *) mBuffers)[(mIsOut ? front : rear) * mFrameSize] : <span class="literal">NULL</span>;
    buffer-&gt;mNonContig = availToServer - part1;
    <span class="comment">// After flush(), allow releaseBuffer() on a previously obtained buffer;</span>
    <span class="comment">// see "Acknowledge any pending flush()" in audioflinger/Tracks.cpp.</span>
    <span class="keyword">if</span> (!ackFlush) {
        mUnreleased = part1;
    }
    <span class="keyword">return</span> part1 &gt; <span class="number">0</span> ? NO_ERROR : WOULD_BLOCK;
    }
no_init:
    buffer-&gt;mFrameCount = <span class="number">0</span>;
    buffer-&gt;mRaw = <span class="literal">NULL</span>;
    buffer-&gt;mNonContig = <span class="number">0</span>;
    mUnreleased = <span class="number">0</span>;
    <span class="keyword">return</span> NO_INIT;
}
</code></pre><p>flush的部分现在不想分析，其他的逻辑又跟clientproxy中<code>obtainBuffer</code>的实现没啥区别，就是少了一个等待时间的统计。</p>
<p>接着看<code>releaseBuffer</code>吧。</p>
<pre><code><span class="keyword">void</span> ServerProxy::releaseBuffer(Buffer* buffer)
{
    LOG_ALWAYS_FATAL_IF(buffer == <span class="literal">NULL</span>);
    <span class="keyword">size_t</span> stepCount = buffer-&gt;mFrameCount;
    <span class="keyword">if</span> (stepCount == <span class="number">0</span> || mIsShutdown) {
        <span class="comment">// prevent accidental re-use of buffer</span>
        buffer-&gt;mFrameCount = <span class="number">0</span>;
        buffer-&gt;mRaw = <span class="literal">NULL</span>;
        buffer-&gt;mNonContig = <span class="number">0</span>;
        <span class="keyword">return</span>;
    }
    <span class="comment">// 更新下有多少个尚未被消费</span>
    mUnreleased -= stepCount;
    <span class="keyword">audio_track_cblk_t</span>* cblk = mCblk;
    <span class="keyword">if</span> (mIsOut) {
        <span class="comment">// 更新front的位置，这边可以看出front也是无限递增的</span>
        <span class="keyword">int32_t</span> front = cblk-&gt;u.mStreaming.mFront;
        android_atomic_release_store(stepCount + front, &amp;cblk-&gt;u.mStreaming.mFront);
    } <span class="keyword">else</span> {
        <span class="keyword">int32_t</span> rear = cblk-&gt;u.mStreaming.mRear;
        android_atomic_release_store(stepCount + rear, &amp;cblk-&gt;u.mStreaming.mRear);
    }
    <span class="comment">// server的指针也跟着挺近。</span>
    cblk-&gt;mServer += stepCount;

    <span class="keyword">size_t</span> half = mFrameCount / <span class="number">2</span>;
    <span class="keyword">if</span> (half == <span class="number">0</span>) {
        half = <span class="number">1</span>;
    }
    <span class="comment">// 这个是我们一开始createTrack的时候就已经给到的值，意思就是消费了多少就可以唤醒client的意思</span>
    <span class="keyword">size_t</span> minimum = (<span class="keyword">size_t</span>) cblk-&gt;mMinimum;
    <span class="keyword">if</span> (minimum == <span class="number">0</span>) {
        <span class="comment">// 为0的话，我们就使用申请buffer的一半，否则就为1</span>
        minimum = mIsOut ? half : <span class="number">1</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (minimum &gt; half) {
        <span class="comment">// 如果大于一半，那我们强制用一半，就是可以早点通知client去生产数据</span>
        minimum = half;
    }
    <span class="keyword">if</span> (!mIsOut || (mAvailToClient + stepCount &gt;= minimum)) {
        <span class="comment">// 开始唤醒操作</span>
        <span class="keyword">int32_t</span> old = android_atomic_or(CBLK_FUTEX_WAKE, &amp;cblk-&gt;mFutex);
        <span class="keyword">if</span> (!(old &amp; CBLK_FUTEX_WAKE)) {
            (<span class="keyword">void</span>) syscall(__NR_futex, &amp;cblk-&gt;mFutex,
                    mClientInServer ? FUTEX_WAKE_PRIVATE : FUTEX_WAKE, <span class="number">1</span>);
        }
    }

    buffer-&gt;mFrameCount = <span class="number">0</span>;
    buffer-&gt;mRaw = <span class="literal">NULL</span>;
    buffer-&gt;mNonContig = <span class="number">0</span>;
}
</code></pre><p>该函数主要实现：</p>
<ol>
<li>更新mUnreleased、front、server等信息</li>
<li>确认什么时候唤醒client生产数据，如果达到，就去唤醒。</li>
</ol>
<p>到此，我们算完成了生产者消费者模型的分析，一开头就已经总结了整个机制。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag">#Android</a>
          
            <a href="/tags/AudioTrack/" rel="tag">#AudioTrack</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/18/audiotrack_play/" rel="next" title="audiotrack的play流程">
                <i class="fa fa-chevron-left"></i> audiotrack的play流程
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/18/audiotrack_write/"
           data-title="audiotrack的write流程" data-url="http://thinks.me/2016/03/18/audiotrack_write/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="LexiMee" />
          <p class="site-author-name" itemprop="name">LexiMee</p>
          <p class="site-description motion-element" itemprop="description">leave me alone</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述"><span class="nav-number">1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者部分"><span class="nav-number">2.1.</span> <span class="nav-text">生产者部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者部分"><span class="nav-number">2.2.</span> <span class="nav-text">消费者部分</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LexiMee</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=0.5.0"></script>



  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"thinks"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
